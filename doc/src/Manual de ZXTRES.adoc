= Manual de ZXTRES, ZXTRES+ y ZXTRES++
:author: kounch
:revnumber: 1.0.0
:doctype: book
:notitle:
:front-cover-image: image:img/portada_zxtres.jpg[]
:email: kounch@users.noreply.github.com
:Revision: 1.0
:description: Manual en castellano de ZXTRES
:keywords: Manual, Castellano, ZXTRES, ZXTRES+. ZXTRES++
:icons: font
:source-highlighter: rouge
:toc: left
:toc-title: Índice
:toclevels: 4

<<<

== Introducción

ZXTRES, ZXTRES+ y ZXTRES++ son la continuación de https://zxuno.speccy.org[ZX-Uno] un proyecto de hardware y software basado en una placa FPGA programada para trabajar como un ordenador ZX Spectrum, y creado por el equipo de ZX-Uno: Superfo, AVillena, McLeod, Quest y Hark0.

Con el paso del tiempo, el proyecto ha ido creciendo, de forma que es posible usar distintas configuraciones de software (cores) y que trabajan como otros sistemas distintos del ZX Spectrum, pudiendo elegir arrancar el ZXTRES con la configuración que se desee de entre varias disponibles.

La página oficial de la familia ZXTRES es .

La mayoría de las funciones y características de ZXTRES, ZXTRES+ y ZXTRES++ son las mismas, así que, en este documento, se hablará, en general, de ZXTRES, indicando las diferencias con los demás donde sea necesario.

=== Agradecimientos

Gran parte del contenido de este documento se basa en información compartida anteriormente:

- En https://www.forofpga.es/[foroFPGA]
- En el https://www.zxuno.com/forum/[foro de ZX-Uno]
- En los varios FAQ existentes, principalmente la versión original https://uto.speccy.org/zxunofaq.html[de @uto_dev], y la versión más moderna http://desubikado.sytes.net/zx-uno-faq-version-desubikado/[de @desUBIKado]
- En los canales oficiales de Telegram de https://t.me/zxuno[ZX-Uno], https://t.me/zxdosfpga[ZXDOS] y https://t.me/zxtresfpga[ZXTRES]
- En la https://github.com/zxtres/wiki/wiki[wiki oficial de ZXTRES]

Sin el trabajo previo de todas estas personas (y más), ese manual no podría existir.

<<<

=== Puertos y Conectores

[.text-center]
image:img/ZXTRESfront.jpg[scaledwidth=90%]

[align="center",width="80%",cols="1,4"]
|===
|1
|Puerto de Joystick Izquierdo
|2
|Ranura microSD
|3
|Puerto de Joystick Derecho
|4
|Enchufe de Alimentación
|5
|Interruptor
|6
|Puerto de Teclado PS/2
|7
|Puerto de Ratón PS/2
|===

<<<

[.text-center]
image:img/ZXTRESback.jpg[scaledwidth=90%]

[align="center",width="80%",cols="1,4"]
|===
|8
|Entrada de Sonido
|9
|Salida de Sonido
|10
|Puerto USB (Sólo utilizable con middleboard instalada)
|11
|Salida RGB/VGA
|12
|Acceso a JTAG
|13
|Puerto de expansión
|14
|Salida DisplayPort
|===

[.text-center]
image:img/ZXTRESbottom.jpg[scaledwidth=90%]

[align="center",width="80%",cols="1,4"]
|===
|15
|Botón de reset
|16
|Interruptor selector de sonido (DeltaSigma o I2S)
|===

<<<

=== Configuración Inicial

Para poder poner en marcha un ZXTRES hace falta, al menos, lo siguiente:

- Un cargador USB, una TV u otro dispositivo que ofrezca alimentación USB (5VDC y, al menos, 1A). El conector es un jack de barril de 5,5mm en el exterior y 2,1mm en el interior, con polaridad positiva (el exterior positivo y el interior negativo)
- Un cable y un monitor o TV con DisplayPort, VGA o RGB (la conexión RGB también se puede utilizar con un adaptador VGA a SCART y conectarse a TV compatibles)
- Un teclado PS/2

[TIP]
====
Es importante que la fuente tenga un voltaje estable y suficiente intensidad, o es posible que ocurran comportamientos erráticos (fallo del teclado, DisplayPort, etc.). Algunos teclados y periféricos podrían requerir el uso de una fuente de alimentación similar pero que ofrezca 2 amperios o más.

[.text-center]
image:img/powerConnector.png[scaledwidth=20%]
====

Para poder aprovechar todo su potencial, es útil tener también:

- Una tarjeta microSD, de 32GB de capacidad o menos
- Unos altavoces de PC para conectar a la salida de audio, o un cable jack-stereo a dos conectores RCA rojo/blanco para conectar a la TV
- Al menos un joystick norma Atari, como por ejemplo, un gamepad DB9 de Megadrive
- Un ratón PS/2
- Un cable con un jack estéreo de 3,5 mm en un extremo y los dos canales de sonido divididos en dos salidas mono en el otro, si se quiere usar algún dispositivo de reproducción y/o grabación de audio, como por ejemplo un Miniduino (<<#_miniduino,ver la sección correspondiente más adelante>>), un PC/Mac/Raspberry PI, etc. o un reproductor/grabador de https://es.wikipedia.org/wiki/Casete[cassette]. El canal derecho se utiliza como entrada (EAR) y el canal izquierdo se puede usar como salida de grabación (MIC).

<<<

==== Formato de la tarjeta microSD

La siguiente tabla resume los requisitos particulares de los distintos cores que utilizan la tarjeta microSD.

[align="center",width="100%",%header,cols="4a,1a,1a,1a,3a,2a,4a,5a",options="header"]
|===
|[.small]#Core#|[.small]#FAT16#|[.small]#FAT32#|[.small]#+3e#|[.small]#Tipo de Partición Primaria#|[.small]#Particiones Extra#|[.small]#Tipo de Acceso#|[.small]#Notas#
|[.small]#ZX Spectrum EXP#|[.small]#Sí#|[.small]#Sí#|[.small]#Sí#|[.small]#Cualquiera#|[.small]#Sí#|[.small]#Completo#|[.small]#Utiliza esxdos de SPI Flash#
|[.small]#ColecoVision#|[.small]#Sí#|[.small]#Sí#|[.small]#No#|[.small]#Cualquiera#|[.small]#No#|[.small]#Sólo ROMs (`.ROM`)#|
|[.small]#Neo-Geo#|[.small]#Sí#|[.small]#Sí#|[.small]#No#|[.small]#Cualquiera#|[.small]#No#|[.small]#Sólo imágenes (`.neo`)#|Necesita BIOS
|[.small]#ZX81#|[.small]#Sí#|[.small]#Sí#|[.small]#No#|[.small]#Cualquiera#|[.small]#No#|[.small]#Sólo imágenes (`.o` y `.p`)#|
|[.small]#zxsp#|[.small]#Sí#|[.small]#Sí#|[.small]#Si#|[.small]#Cualquiera#|[.small]#No#|[.small]#Imágenes de disco (`.vhd`)#|Necesita ROM
|===

[NOTE]
====
El tamaño máximo de una partición FAT16 son 4GB
====

[CAUTION]
====
A la hora de poner el nombre a una partición que se vaya a utilizar con esxdos, es importante no utilizar el mismo que el de cualquiera de los directorios dentro, o se producirá un error de acceso a ese directorio. (Ej: No llamar a la partición `BIN`, `SYS` o `TMP`).
====

[TIP]
====
Para el core de Spectrum, tambén es posible tener <<#_formato_avanzado_de_la_tarjeta_microsd_3e,una primera partición en formato +3DOS y luego otra(s) en formato FAT16 o FAT32>>, para su uso con una ROM de +3e.
====

<<<

===== Windows

Para configuraciones sencillas, y tarjetas del tamaño adecuado (menos de 2GB para FAT16 o menos de 32GB para FAT32), se puede utilizar https://www.sdcard.org/downloads/formatter/[la herramienta de formato oficial de la SD Association].

Para otras configuraciones, y según la versión de sistema operativo de que se disponga, se podrá utilizar la herramienta de línea de comandos `diskpart` o bien la interfaz gráfica de administración de discos del sistema.

Por ejemplo, en Windows, para formatear una tarjeta con una única partición FAT16 (si la tarjeta es de 4GB o menos de tamaño), que figura como disco 6 al ejecutar `list disk` desde `diskpart`:

[source]
----
select disk 6
clean
create part primary
active
format FS=FAT label=ZXTRES
exit
----

Para crear dos primeras particiones FAT16 de 4GB (por ejemplo, para usar con el core de MSX) y usar el resto del espacio con otra más en formato FAT32 (para tarjetas de más de 8GB):

[source]
----
select disk 6
clean
create part primary size=4000
set id = 06
active
format fs=FAT label=ZXTRES quick
create part primary size=4000
format fs=FAT label=EXTRA quick
create part primary
format fs=FAT32 label=DATA quick
exit
----

Para crear una partición FAT32 de 4GB (por ejemplo, para usar con el core de Amstrad CPC 6128) y usar el resto del espacio con otra más en formato FAT32 (para tarjetas de más de 4GB de tamaño):

[source]
----
select disk 6
clean
create part primary size=4000
set id = 0b
active
format fs=FAT32 label=ZXTRES unit=4k quick
create part primary
format fs=FAT32 label=EXTRA quick
exit
----

<<<

===== MacOS

Para configuraciones sencillas, y tarjetas del tamaño adecuado (menos de 2GB para FAT16 o menos de 32GB para FAT32), se puede utilizar https://www.sdcard.org/downloads/formatter/[la herramienta de formato oficial de la SD Association] o la Utilidad de Discos incluida con el sistema operativo.

Para configuraciones más complejas, será necesario utilizar la línea de comandos.

Por ejemplo, en MacOS, para formatear una tarjeta con una única partición FAT16 (si la tarjeta es de 2GB o menos de tamaño), que figura como `disk6` en la lista de dispositivos:

[source,shell]
----
diskutil unmountDisk /dev/disk6
diskutil partitionDisk /dev/disk6 MBR "MS-DOS FAT16" ZXTRES R
----

Para dividirla en dos particiones iguales (si la tarjeta es de 4GB o menos de tamaño):

[source,shell]
----
diskutil unmountDisk /dev/disk6
diskutil partitionDisk /dev/disk6 MBR "MS-DOS FAT16" ZXTRES 50% "MS-DOS FAT16" EXTRA 50%
----

Para crear dos primeras particiones FAT16 de 4GB (por ejemplo, para usar con el core de MSX) y usar el resto del espacio con otra más en formato FAT32 (para tarjetas de más de 8GB):

[source,shell]
----
diskutil unmountDisk /dev/disk6
diskutil partitionDisk /dev/disk6 MBR %DOS_FAT_16% ZXTRES 4G %DOS_FAT_16% EXTRA 4G "MS-DOS FAT32" DATA R
sudo newfs_msdos -F 16 -v ZXTRES -c 128 /dev/rdisk6s1
sudo newfs_msdos -F 16 -v EXTRA -c 128 /dev/rdisk6s2
----

[NOTE]
====
El comando `diskutil` no permite crear particiones FAT16 de más de 2G de tamaño y formatearlas a la vez. Por eso, en el último caso, se crean primero las particiones y luego se formatean en FAT16.
====

<<<

Para crear una partición FAT32 de 4GB (por ejemplo, para usar con el core de Amstrad CPC 6128) y usar el resto del espacio con otra más en formato FAT32 (para tarjetas de más de 4GB de tamaño):

[source,shell]
----
diskutil unmountDisk /dev/disk6
diskutil partitionDisk /dev/disk6 MBR "MS-DOS FAT32" ZXTRES 4G "MS-DOS FAT32" EXTRA R
----

[NOTE]
====
Para el core de Amstrad CPC, en este caso, al elegir exactamente un tamaño de partición de 4G, MacOS elegirá por defecto un tamaño de cluster de 4096. Para un tamaño inferior, podría ser necesario volver a formatear la primera partición con unos comandos similares a estos:

[source,shell]
----
diskutil unmountDisk /dev/disk6
newfs_msdos -F 32 -v ZXTRES -b 4096 /dev/rdisk6s1
----
====

[TIP]
====
Por defecto, MacOS indexa y guarda información extra en archivos de los discos externos. Esto se puede minimizar usando estos comandos (suponiendo que la partición de la microSD se llama `ZXTRES`):

[source,shell]
----
mdutil -i off /Volumes/ZXTRES
cd /Volumes/ZXTRES
rm -rf .{,_.}{fseventsd,Spotlight-V*,Trashes}
mkdir .fseventsd
touch .fseventsd/no_log .metadata_never_index .Trashes
cd -
----
====

<<<

===== Linux

Existen multitud de herramientas en Linux que permiten formatear y particionar el contenido de una tarjeta microSD (como `fdisk`, `parted`, `cfdisk`, `sfdisk` o `GParted`). Sólo se ha de tener en cuenta que el esquema de particiones a utilizar siempre ha de ser MBR, y la primera partición (la que se utilizará para esxdos) ha de ser primaria.

Por ejemplo, para formatear una tarjeta con una única partición FAT16 (si la tarjeta es de 4GB o menos de tamaño), que figura como `sdc` en la lista de dispositivos:

[source,shell]
----
sudo fdisk --compatibility=dos /dev/sdc
----

[source]
----
(...)
Command (m for help): n
Partition type
   p   primary (0 primary, 0 extended, 4 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (1-4, default 1): 1
First sector (62-31116288, default 62):
Last sector, +/-sectors or +/-size{K,M,G,T,P} (128-31116288, default 31116288):
Created a new partition 1 of type 'Linux'

Command (m for help): t
Selected partition 1
Hex code (type L to list all codes): 6
Changed type of partition 'Linux' to 'FAT16'.

Command (m for help): a
Partition number (1, default 1): 1
The bootable flag on partition 1 is enabled now.

Command (m for help): p
Disk /dev/sdc
Disklabel type: dos
Disk identifier

Device     Boot   Start     End  Sectors   Size Id Type
/dev/sdc1           62 31116288  31116288 984,9M 6 FAT16
----

Formatear la partición FAT (requiere permisos de root)

[source,shell]
----
sudo mkfs.fat -F 16 -n ZXTRES -s 128 /dev/sdc1
----

<<<

=== Teclado

==== Teclado PS/2

El mapa de un teclado conectado al puerto PS/2 (asignación de las teclas físicas del teclado con las pulsaciones que se presentan a los distintos cores) se cambia desde el menú `Advanced` de la BIOS. Existen tres mapas distintos a elegir: Español (por defecto), inglés, y Spectrum (avanzado).

También se puede cambiar con la utilidad `keymap`. Dentro de `/bin` hay que crear un directorio llamado `keymaps` y ahí copiar los mapas de teclado se desee usar. Por ejemplo, para cambiar al mapa US hay que escribir `.keymap us` desde esxdos.

Para que el mapa se conserve después de un master reset, hay que tener seleccionado `Default` en la configuración de BIOS.

Para más información, consultar https://www.zxuno.com/forum/viewtopic.php?f=37&t=208[este mensaje en el foro de ZX-Uno].

*Español*

[.text-center]
image:./img/keyboardEsp.png[scaledwidth=70%]

*Inglés*

[.text-center]
image:./img/keyboardEng.png[scaledwidth=70%]

*Spectrum*

[.text-center]
image:./img/keyboardAV.png[scaledwidth=70%]

<<<

==== Teclas especiales y botones

Teclas especiales durante el arranque:

- `F2` Entrar en la BIOS
- `Bloq. Mayús` o `Cursor abajo` o, si hay un joystick conectado, pulsar la dirección hacia abajo: Menú de selección de cores
- `Esc` o, si hay un joystick de dos o más botones conectado, pulsar el botón de disparo 2: Menú de selección de ROMS del core de ZX Spectrum
- `R`: Carga la rom del core de ZX Spectrum en modo "real" deshabilitando esxdos, nuevos modos gráficos, etc.
- `/` (del teclado numérico): Carga la ROM por defecto del core de ZX Spectrum en modo "root"
- Número del `1` al `9`: Cargar el core en la ubicación de la Flash correspondiente a dicho número. En las versiones más recientes de BIOS, la tecla `9` carga el core del slot temporal utilizado por el <<#_navegador_de_bob_fossil,plugin ZX3>>.

Teclas especiales que se pueden utilizar durante la ejecución del core principal (ZX Spectrum):

- `Esc`: BREAK
- `F2`: Edit
- `F5`: NMI
- `F7`: Reproducir o Pausa en la reproducción de archivos .PZX
- `F8`: Rebobinar el archivo .PZX hasta la marca anterior
- `F10`: Graph
- `F12`: Turbo Boost. Pone a la CPU a 28MHz 
- `Ctrl+Alt+Backspace`: Hard reset. Backspace es la tecla de borrar hacia atrás, encima de `Enter`
- `Ctrl+Alt+Supr`: Soft reset
- `Bloq. Despl.`: cambia de modo vídeo RGB a VGA y viceversa (DisplayPort está siempre activo)
- `Inicio`: Alterna entre los distintos modos de gestión del desentrelazado en DisplayPort (Blend, Off, Auto y On). Esta opción sólo está disponible en los cores para ZXTRES+ y ZXTRES++
- `Fin`: Activa los distintos modos de color monocromo

<<<

=== esxdos

https://esxdos.org/index.html[esxdos] es un firmware para la interfaz the DivIDE/DivMMC, que el ZXTRES implementa, y que permite el acceso a dispositivos de almacenamiento como la tarjeta microSD. Incluye comandos similares a los de UNIX, aunque para usarlos hay que precederlos con un punto, por ejemplo `.ls`, `.cd`, `.mv`, etc.

Para poder utilizarlo es necesario incluir los ficheros correspondientes en la primera partición de la tarjeta microSD.

En el momento de escribir este documento, la versión incluida con ZXTRES es la 0.8.9, y se puede descargar desde la página oficial https://www.esxdos.org/files/esxdos086.zip[en este enlace].

Una vez descargado y descomprimido, se han de copiar, a la raíz de la tarjeta, los directorios `BIN`, `SYS` y `TMP` con todo su contenido.

Si todo se ha hecho correctamente, al encender el core Spectrum de ZXTRES se verá cómo esxdos detecta la tarjeta y carga los componentes necesarios para funcionar.

[.text-center]
image:./img/esxdos.png[scaledwidth=70%]

<<<

Es recomendable, además, añadir los comandos esxdos específicos para ZXTRES. Estos se pueden obtener en la página con el código fuente del proyecto (https://github.com/zxdos/zxuno/tree/master/SD[aquí], https://github.com/zxdos/zxuno/tree/master/[aquí] y https://guest:zxuno@svn.zxuno.com/svn/zxuno/software/upgrade[aquí]), y son los siguientes:

    back16m
    backzx2
    backzxd
    corebios
    dmaplayw
    esprst
    iwconfig
    joyconf
    keymap
    loadpzx
    loadtap
    playmid
    playrmov
    romsback
    romsupgr
    upgr16m
    upgrzx2
    upgrzxd
    zxuc
    zxunocfg

<<#_comandos_para_zxtres,Más adelante>> se explica lo que hace cada uno de ellos.

<<<

=== BIOS

[.text-center]
image:./img/boot_zxtres.png[scaledwidth=80%]

Si se pulsa la tecla `F2` durante el arranque, se tendrá acceso a la configuración de BIOS. El firmware de BIOS es el primer programa que se ejecuta cuando se enciende el ZXTRES. El propósito fundamental del software de BIOS es iniciar y probar el hardware y cargar uno de los cores instalados.

Usando las teclas de cursor izquierda y derecha, se puede navegar por las pantallas de configuración de la BIOS. Con las teclas arriba y abajo se pueden elegir los distintos elementos de cada pantalla y, con la tecla `Enter`, es posible activar y elegir las opciones de cada una de estas. La tecla `Esc` sirve para cerrar las ventanas de opciones abiertas sin aplicar ninguna acción.

Otras teclas que se pueden pulsar durante el arranque de la BIOS son:

- `Bloq. Mayús` o `Cursor abajo`, o `Caps Shif+6` o `Caps Shift+2` o, si hay un joystick conectado, pulsar la dirección hacia abajo: Menú de selección de cores
- `Esc` o `Caps Shift+Espacio`, o si hay un joystick de dos o más botones conectado, pulsar el botón de disparo 2: Menú de selección de ROMS del core de ZX Spectrum
- `R`: Carga la rom del core de ZX Spectrum en modo "real" deshabilitando esxdos, nuevos modos gráficos, etc. (combinado con `Esc` a continuación permite elegir otra ROM distinta)
- `/` (del teclado numérico) o `Symbol Shift+V`: Carga la ROM por defecto del core de ZX Spectrum en modo "root" (combinado con `Esc` a continuación permite elegir otra ROM distinta)
- Número del `1` al `9`: Cargar el core en la ubicación de la Flash correspondiente a dicho número. En las versiones más recientes de BIOS, la tecla `9` carga el core del slot temporal utilizado por el <<#_navegador_de_bob_fossil,plugin ZX3>>.

<<<

==== Main

[.text-center]
image:img/bios.png[scaledwidth=70%]

En la primera pantalla de configuración, además de poder ejecutar distintas pruebas, se puede definir el comportamiento por defecto para lo siguiente:

- Espera en el arranque (Boot Timer): Indica el tiempo que está la pantalla de arranque disponible (o la oculta por completo)
- Comprobar CRC de las ROMs (Check CRC): Para comprobar la integridad de las ROMs al cargarlas (más seguro) u omitirla (más rápido)
- Tipo de teclado (Keyboard)
- Timing: Para definir el comportamiento de la ULA (Modo 48K, Modo 128K, Modo Pentagon)
- Contención de memoria (Contended)
- DivMMC
- Soporte NMI para DivMMC
- Soporte para nuevos modos gráficos (ULAPlus, Timex, Radastan)

Se puede consultar información más tecnica en https://www.zxuno.com/wiki/index.php/ZX_Spectrum[la Wiki de ZX-Uno].

<<<

==== ROMs

[.text-center]
image:img/bios2.png[scaledwidth=70%]

La segunda pantalla muestra las ROMs de ZX Spectrum instaladas y permite reordenar (Move Up, Move Down), renombrar (Rename) o borrar (Delete) cada una de ellas, así como elegir la que se cargará por defecto en el arranque (Set Active).

==== Upgrade

[.text-center]
image:img/bios3_zxtres.png[scaledwidth=70%]

La pantalla _Upgrade_ se utiliza para realizar las distintas actualizaciones del contenido de la memoria Flash: esxdos, BIOS, Cores, etc. (véase <<#_actualizaciones,el apartado correspondiente a actualizaciones>> para más información).

==== Boot

[.text-center]
image:img/bios4_zxtres.png[scaledwidth=70%]

En la pantalla _Boot_ se puede elegir qué core de los instalados se desea que cargue por defecto en el arranque.

<<<

==== Advanced

[.text-center]
image:img/bios5_zxtres.png[scaledwidth=70%]

La pantalla de configuración avanzada sirve para modificar los siguientes ajustes:

- Distribución del teclado (Keyb Layout): Ver <<#_teclado,el apartado correspondiente >> para más información)
- Comportamiento de un joystick conectado al puerto de joystick derecho, y también del joystick emulado con el teclado numérico (Joy Keypad): Kempston, Sinclair Joystick 1, Sinclair Joystick 2, Protek, Fuller o simular las teclas `Q`, `A`, `O`, `P`, `Espacio` y `M`
- Comportamiento de un joystick conectado al puerto de joystick izquierdo (Joy DB9): Kempston, Sinclair Joystick 1, Sinclair Joystick 2, Protek, Fuller o simular las teclas `Q`, `A`, `O`, `P`, `Espacio` y `M`
- Salida de vídeo (Video): PAL, NTSC o VGA (DisplayPort está siempre activo)
- Simulación de línea de exploración (Scanlines): Activas (Enabled) o inactivas (Disabled)
- Frecuencia horizontal de VGA (Frequency): 50, 51, etc.
- Velocidad de la CPU: Normal (1x) o acelerada (2X, 3X, etc.)
- Csync: Spectrum o PAL

<<<

==== Exit

[.text-center]
image:img/bios6.png[scaledwidth=70%]

Finalmente, desde la última pantalla se puede:

- Salir de la configuración de BIOS guardando los cambios (Save Changes & Exit)
- Descartar los cambios y salir (Discard Changes & Exit)
- Guardar los cambios sin salir (Save Changes)
- Descartar los cambios (Discard Changes)

== ZX Spectrum

El core principal es el que implementa un ordenador ZX Spectrum. Este core es especial, y no se puede sustibuir por otro que no sea de ZX Spectrum, ya que el ZXTRES lo utiliza para su funcionamiento.

Estas son algunas de sus principales características:

- Implementación ZX Spectrum 48K, 128K, Pentagon y Chloe 280SE
- ULA con modos ULAplus, Timex y modo Radastan (incluyendo scroll por hardware y grupo de paleta seleccionable)
- Posibilidad de desactivar la contención de memoria (para compatibilidad con Pentagon 128)
- Posibilidad de elegir el comportamiento del teclado (issue 2 o issue 3)
- Posibilidad de elegir el timing de la ULA (48K, 128K o Pentagon)
- Control del encuadre de pantalla configurable para tipo de timing, y posibilidad de elegir entre sincronismos originales de Spectrum o sincronismos estándar PAL progresivo.
- Soporte de la MMU horizontal del Timex con bancos HOME, DOC y EXT en RAM.
- Interrupción ráster programable en número de línea, para cualquier linea de TV.
- Posibilidad de activar/desactivar los registros de manejo de bancos de memoria, para mejor compatibilidad con cada modelo implementado
- Posibilidad de activar/desactivar los dispositivos incorporados al core para mejorar la compatibilidad con ciertos programas
- Soporte ZXMMC y DIVMMC para para +3e, esxdos y firmwares compatibles
- Soporte Turbo Sound
- Soporte de SpecDrum
- Cada canal A,B,C de los dos chips AY-3-8912, beeper y SpecDrum pueden dirigirse a las salidas izquierda, derecha, ambas o ninguna, permitiendo la implementación de configuraciones tales como ACB, ABC, etc.
- Soporte de joystick real y joystick en teclado con protocolo Kempston, Sinclair 1 y 2, Cursor, Fuller y QAOPSpcM.
- Soporte de modo turbo a 7MHz, 14MHz, 28MHz
- Soporte de teclado con protocolo PS/2 y mapeado configurable desde el propio Spectrum.
- Soporte de ratón PS/2 emulando el protocolo Kempston Mouse.
- Posibilidad de salida de vídeo en modo RGB 15kHz, VGA y DisplayPort
- Frecuencia de refresco vertical seleccionable para la compatibilidad con monitores VGA
- Soporte de arranque multicore: desde el Spectrum se puede seleccionar una dirección de la SPI Flash y la FPGA cargará un core desde ahí
- Modos de color incluyendo monocromo o fósforo verde/naranja
- Salida de audio I^2^S y DeltaSigma
- Soporte Wi-Fi (UART)
- Soporte MIDI (General MIDI) vía middleboard
- Carga de ficheros `PZX` desde la SD simulando carga de cinta
- Varios modos de gestión del desentrelazado en la salida DisplayPort incluyendo una opción para mezclar (blend) los colres. Esto sólo está disponible en los cores para ZXTRES+ y ZXTRES++

<<<

=== ROMs

El core de ZX Spectrum tiene la capacidad de inicializar utilizando diferentes versiones de ROM (48K, 128K, Plus 2, etc.). Estas se almacenan en la memoria flash del ZXTRES, y se puede elegir cuál cargar, pulsando la tecla `Esc` durante el arranque. También es posible definir desde la configuración de BIOS, cuál es la ROM que se desea que se cargue por defecto.

Véase el <<#_roms_3,apartado de actualizaciones>> para más información sobre cómo ampliar o modificar las ROMs almacenadas en la memoria flash.

==== DerbyPro

https://www.facebook.com/groups/DerbyPro[DerbyPro o Derby{pp}] es una ROM mejorada para el ZX Spectrum, basada en la versión 1.4 de la ROM de desarrollo Derby. El Spectrum 128 (nombre en código "Derby") fue una máquina española, encargada por Investronica y lanzada en 1985. Incluía un teclado aparte que añadía varias teclas de edición extra. En 1986 se lanzó la versión para Reino Unido con una versión simplificada de 128 BASIC y sin teclado extra. Derby++ se basa en la ROM española para incluir lo mejor de las dos versiones, sin sus inconvenientes, y con soporte para nuevo hardware.

Se puede descargar la ROM, un manual de usuario y otos ficheros del https://www.facebook.com/groups/DerbyPro[grupo púbilco oficial de Facebook].

Esta ROM de 64K tiene soporte para nuevo hardware, incluyendo el uso de comandos de esxdos desde 128 BASIC, así que se pueden usar estas opciones al <<#_zx123_tool,añadirla a la SPI flash>>:

[%header,cols=2*]
|===
|Ajuste
|Significado
|`d`
|Habilitar DivMMC
|`n`
|Habilitar NMI DivMMC (menú de esxdos)
|`t`
|Usar timings de 128K
|===

<<<

==== CargandoLeches

https://github.com/antoniovillena/CargandoLeches[CargandoLeches] es un conjunto de ROMs de ZX Spectrum originalmente pensadas para cargar juegos a una velocidad de 15 a 20 veces superior a lo normal. En lugar de una cinta se requiere una fuente de audio digital como un ordenador, un dispositivo móvil, un reproductor MP3, etc. También tiene una rutina que detecta el método de carga y si no se trata de una carga ultrarápida, ejecuta el código de la ROM original. En cargas que no sean CargandoLeches no se nota por tanto la diferencia entre usar esta ROM y la ROM original.

Desde la versión 2.0, el proyecto pasó de ser una única ROM a varias, cada una con distintas opciones. Así, es posible elegir diferentes combinaciones que pueden incluir:

- Carga ultrarrápida
- Reset & Play (es decir, que al hacer un reset automáticamente se ponga en modo carga de cinta)
- Introducción de POKEs
- Desactivar o activar la expansión de tokens (palabras clave) de Sinclair BASIC

El conjunto completo de ROMs está disponible para descargar desde el repositorio en GitHub https://github.com/antoniovillena/CargandoLeches/tree/master/binaries[aquí].

Dependiendo de la ROM elegida, los ajustes a indicar cuando se <<#_zx123_tool,añada a la SPI flash>> pueden variar. Por ejemplo, para la ROM `48le_ea_re_po` (que tiene habilitadas todas las opciones), se pueden usar estos ajustes (no hay que habilitar NMI DivMMC porque el editor de POKEs ya lo utiliza):

[%header,cols=2*]
|===
|Ajuste
|Significado
|`d`
|Habilitar DivMMC
|`h`
|Deshabilitar bit alto de ROM (bitd 2 de 1FFD)
|`l`
|Deshabilitar bit bajo de ROM (bit 4 de 7FFD)
|`x`
|Deshabilitar modo Timex
|===

===== POKEs

En el caso de usar una ROM con la opción de introducir POKEs, se hace de la siguiente manera:

. Una vez el juego ha cargado, pulsando NMI (`F5`), aparecerá un campo en la parte superior izquierda de la pantlla
. Escribir la dirección del POKE a introducir y pulsar `Enter`
. Escribir el valor del POKE y pulsar `Enter`
. Repetir los pasos 2. y 3. todas las veces que se desee. Para terminar y volver al juego, pulsar `Enter` dos veces seguidas

<<<

===== Preparación de cintas de carga ultrarrápida

Las ROMs con la opción de carga ultrarrápida necesitan archivos de cinta especiales que se generan desde ficheros `TAP` de carga normal, de juegos que no tengan protección de carga o modo turbo.

Para crear una cinta de carga ultrarrápida se necesitan las utilidates de línea de comandos `leches` y `CgLeches`. Estas se pueden conseguir, para Windows, https://github.com/antoniovillena/CargandoLeches/tree/master/binaries[en el repositorio oficial]. Para MacOS es posible descargar una versión no oficial https://github.com/kounch/CargandoLeches/tree/master/binaries/MacOS[en este otro repositorio].

En otro caso, es posible compilar desde https://github.com/antoniovillena/CargandoLeches[el código fuente disponible en el repositorio oficial]. Por ejemplo, para compilar en Linux usando `gcc` basta con usar estos comandos:

[source,shell]
----
gcc leches.c -o leches
gcc CgLeches.c -o CgLeches
----

Para generar una cinta de carga ultarrápida se ha de invocar desde una consola al comando `CgLeches` indicando, al menos, el fichero `TAP` de origen, y el fichero (`WAV` o `TZX`) de destino. Existen otros parámetros como el nivel de velocidad de la carga, entre 0 y 7 (donde 0 es la más rápida pero posiblemente más incompatible), si se desea un fichero mono, estéreo, etc. (en el caso de `WAV`) y más.

Así, para producir un fichero `WAV` de audio con una cinta de carga ultrarrápida desde el fichero de cinta `Valley.tap` con velocidad de carga 5, se haría así:

[source,shell]
----
(...) CgLeches Valley.tap Valley.wav 5
----

Ahora el fichero `Valley.wav` se puede reproducir desde un ordenador u otro dispositivo y cargarlo usando la ROM (véase la sección dedicada a la <<#_carga_desde_cinta,carga desde cinta>> para más detalles).

[WARNING]
====
Debido a limitaciones en el hardware, los ficheros `TZX` generados con `CgLeches` no funcionan correctamente con <<#_miniduino,Miniduino>>, aunque sí que suelen funcionar con <<#_playtzx,`PlayTZX`>>.
====

<<<

==== SE Basic IV

https://github.com/cheveron/sebasic4[SE Basic IV] es un intérprete de Microsoft BASIC, gratuito y de código abierto. SE Basic IV se ha diseñado para funcionar en un https://www.patreon.com/chloe280se[Chloe 280SE] pero también lo hace en ZX-Uno y similares.

SE Basic se pensó en sus orígenes como un nuevo firmware para el https://sinclair.wiki.zxnet.co.uk/wiki/ZX_Spectrum_SE[ZX Spectrum SE]. Las primeras versiones eran modificaciones aplicadas sobre la ROM original del ZX Spectrurm, pero posteriormente se ha reescrito basándose en la https://groups.google.com/g/comp.sys.sinclair/c/F90HbKTDkRk[ROM mejorada y de código abierto TS1000 / ZX81].

La versión 3, también conocida como https://zxdesign.itch.io/opense[OpenSE BASIC], todavía se mantiene como un firmware de código abierto para el Spectrum. Se incluye, por ejemplo, en el https://tracker.debian.org/pkg/opense-basic[repositorio principal de Debian] para su uso en emuladores.

La versión IV es una nueva rama de la versión anterior, creada principalmente porque no quedaba espacio para añadir nuevas características a la ROM de 16K. La primera versión (4.0 Anya) añadió una segunda ROM de 16K con soporte para el modo hi-res de Timex. La sintaxis era aún bastante compatible con Sinclair BASIC. La versión 4.2 fue reconstruida específicamente para el Chloe 280SE, eliminó el soporte para dispositivos antiguos como las cintas, añadió soporte integrado y compatibilidad total con el kernel de esxdos, y migró a la sintaxis de Microsoft BASIC.

Aunque guarda una base común de código con muchas versiones de Sinclair BASIC (la ROM TS1000), hay varias diferencias significativas:

- Soporte para páginas de códigos(8-bit ASCII).
- Traducción de los mensajes de error.
- 38 tokens nuevos.
- Presentación en una terminal estándar (80 x 24).
- Introducción de caracteres de terminal (CTRL, META).
- Buffer de teclado.
- Soporte para teclados completos.
- Soporte completo de las características adicionales del core de Spectrum de ZX-Uno

Las principales diferencias con Microsoft BASIC son:

- Abreviación de tokens.
- Comprobación de sintaxis en cada entrada.
- Normalmente los paréntesis son opcionales.
- Introducción de número con el estilo Motorola:
  % – binario
  @ – octal
  $ – hexadecimal
- Evaluación de expresiones siempre activa.
- Operadores lógicos y bit a bit separados.
- Tipado automático de datos.

Se puede encontrar mucha más información, incluyendo el manual de usuario, etc. en https://github.com/cheveron/sebasic4/wiki[la wiki oficial].

<<<

==== Otras ROMs

Estos son algunos ajustes válidos para <<#_zx123_tool,añadir a la SPI flash>> algunas otras ROM personalizadas:

[%header,cols=2*]
|===
|Nombre de la ROM
|Ajustes
|Gosh Wonderful ROM v1.33
|dnhl17x
|Looking Glass 1.07
|dnhl17x
|ZX82 by Daniel A. Nagy
|dnhl17
|ZX85 by Daniel A. Nagy
|dntmh1
|Arcade Game Designer 0.1
|thl17x
|===

<<<

=== Formato avanzado de la tarjeta microSD (+3e)

Una de las ROM que se pueden cargar con el core de ZX Spectrum es la de ZX Spectrum +3e, que es una versión mejorada del Sinclair ZX Spectrum +3, y que soporta el uso de discos duros o tarjetas de memoria.

El +3e usa su propio esquema de particionado (llamado IDEDOS) para dividir el disco duro en diferentes particiones donde se pueden almacenar datos. Se necesita una version 1.28 o superior de la ROM para poder compartir particiones IDEDOS con particiones MBR. En otro caso, se ha dedicar la tarjeta completa al particionado IDEDOS.

[IMPORTANT]
====
El esquema de particionado que se presentará a continuación sólo se podrá utilizar con el core de Spectrum. Otros cores que necesiten acceso a la tarjeta SD posiblemente fallen o no se inicien correctamente, si se encuentra insertada una SD con este formato.
====

[TIP]
====
En IDEDOS, cada partición puede tener un tamaño entre 1 y 16 Megabytes (16 millones de bytes), y cada disco puede tener entre 1 y 65535 particiones. Por tanto, lo máximo que se puede ocupar de una tarjeta será alrededor de 1 TB de espacio.
====

A continuación se explica una forma de dividir una tarjeta en dos o tres partes, con la primera partición IDEDOS (1GB de tamaño), la segunda FAT16 (4GB) y la tercera FAT32 (resto del espacio de la tarjeta).

En la segunda particion se puede instalar, tal y como se explicó anteriormente <<#_esxdos,exsdos>> y otros programas.

==== Windows

Se puede utilizar el administrador de discos de Windows. Los pasos a seguir serían:

. Eliminar todas las particiones de la tarjeta

. Crear una partición extendida, del tamaño que se quiera utilizar para IDEDOS

. Crear una partición primaria de 4GB y formatear como FAT16

. Opcionalmente, crear otra partición primaria ocupando el resto del espacio y formatear como FAT32

<<<

==== MacOS

Será necesario utilizar la línea de comandos. Lo primero es determinar el disco a formatear:

[source,shell]
----
diskutil list
----

En este ejemplo sería el disco 6:

[source]
----
(...)
/dev/disk6 (external, physical):
   #:                       TYPE NAME                    SIZE       IDENTIFIER
   0:     FDisk_partition_scheme                        *15.9 GB    disk6
   1:                 DOS_FAT_32 UNKNOWN                 15.9 GB    disk6s1
----

Pasos a seguir:

. Expulsar el disco y editar el esquema de particiones (el segundo paso requiere permisos de administrador):

[source,shell]
----
diskutil unmountDisk /dev/disk6
sudo fdisk -e /dev/rdisk6
----

[source]
----
fdisk: could not open MBR file /usr/standalone/i386/boot0: No such file or directory
Enter 'help' for information
fdisk: 1> erase
fdisk:*1> edit 1
Partition id ('0' to disable)  [0 - FF]: [0] (? for help) 7F
Do you wish to edit in CHS mode? [n]
Partition offset [0 - 31116288]: [63] 128
Partition size [1 - 31116287]: [31116287] 2017152

fdisk:*1> edit 2
Partition id ('0' to disable)  [0 - FF]: [0] (? for help) 06
Do you wish to edit in CHS mode? [n]
Partition offset [0 - 31116288]: [2017280]
Partition size [1 - 29099135]: [29099135] 7812504

fdisk:*1> flag 2
----

[source]
----
fdisk:*1> edit 3
Partition id ('0' to disable)  [0 - FF]: [0] (? for help) 0B
Do you wish to edit in CHS mode? [n]
Partition offset [0 - 31116288]: [9829784]
Partition size [1 - 21286504]: [21286504]

fdisk:*1> print
         Starting       Ending
 #: id  cyl  hd sec -  cyl  hd sec [     start -       size]
------------------------------------------------------------------------
 1: 7F 1023 254  63 - 1023 254  63 [       128 -    2017152] <Unknown ID>
 2: 06 1023 254  63 - 1023 254  63 [   2017280 -    7812504] DOS > 32MB
 3: 0B 1023 254  63 - 1023 254  63 [   9829784 -   21286504] Win95 FAT-32
 4: 00    0   0   0 -    0   0   0 [         0 -          0] unused

fdisk:*1> write
fdisk: 1> quit
----

[start=2]
. Formatear las particiones FAT (requiere permisos de administrador)

[source,shell]
----
diskutil unmountDisk /dev/disk6
sudo newfs_msdos -F 16 -v ZXTRES -c 128 /dev/rdisk6s2
sudo newfs_msdos -F 32 -v EXTRA -b 4096 -c 128 /dev/rdisk6s3
----

[start=3]
. Comprobar cómo el esquema de particiones ha cambiado y ya es el que se deseaba:

[source,shell]
----
diskutil list
----

[source]
----
(...)
/dev/disk6 (external, physical):
   #:                       TYPE NAME                    SIZE       IDENTIFIER
   0:     FDisk_partition_scheme                        *15.9 GB    disk6
   1:                       0x7F                         1.0 GB     disk6s1
   2:                 DOS_FAT_16 ZXTRES               4.0 GB     disk6s2
   3:                 DOS_FAT_32 EXTRA                   10.9 GB    disk6s3
----

<<<

==== Linux

Será necesario utilizar la línea de comandos. Lo primero es determinar el disco a formatear:

[source,shell]
----
lsblk
----

En este ejemplo sería `sdc`:

[source]
----
NAME         MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
(..)
sdc          179:0    0 15,8G  0 disk
└─sdc1       179:1    0 15,8G  0 part
----

Pasos a seguir:

. Comprobar que no está montado y editar el esquema de particiones (este paso requiere permisos de root):

[source,shell]
----
sudo fdisk --compatibility=dos /dev/sdc
----

[source]
----
Welcome to fdisk
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Command (m for help): n
Partition type
   p   primary (0 primary, 0 extended, 4 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (1-4, default 1): 1
First sector (62-31116288, default 62): 128
Last sector, +/-sectors or +/-size{K,M,G,T,P} (128-31116288, default 31116288): 2017152

Created a new partition 1 of type 'Linux'

Command (m for help): t
Selected partition 1
Hex code (type L to list all codes): 7f
Changed type of partition 'Linux' to 'unknown'.

Command (m for help): n
Partition type
   p   primary (1 primary, 0 extended, 3 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (2-4, default 2):
First sector (45-31116288, default 45): 2017280     .
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2017153-31116288, default 31116288): 7812504

Created a new partition 2 of type 'Linux'

Command (m for help): t
Partition number (1,2, default 2): 2
Hex code (type L to list all codes): 6

Changed type of partition 'Linux' to 'FAT16'.

Command (m for help): a
Partition number (1,2, default 2): 2

The bootable flag on partition 2 is enabled now.

Command (m for help): n
Partition type
   p   primary (2 primary, 0 extended, 2 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (3-4, default 3): 3
First sector (45-31116288, default 45): 9829784     .
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2017153-31116288, default 31116288): 31116288

Created a new partition 3 of type 'Linux'

Command (m for help): t
Partition number (1-4, default 3): 3
Hex code (type L to list all codes): b

Changed type of partition 'Linux' to 'W95 FAT32'.

Command (m for help): p
Disk /dev/sdc
Disklabel type: dos
Disk identifier

Device     Boot   Start     End  Sectors   Size Id Type
/dev/sdc1           128 2017152  2017025 984,9M 7f unknown
/dev/sdc2  *    2017280 7626751  7812504   2,7G  b FAT16
/dev/sdc3       9829784 7626751 21286504    21G  b W95 FAT32
----

[start=2]
. Formatear las particiones FAT (requiere permisos de root)

[source,shell]
----
sudo mkfs.fat -F 16 -n ZXTRES -s 128 /dev/sdc2
sudo mkfs.fat -F 32 -n EXTRA -s 128 /dev/sdc3
----

[start=3]
. Verificar que el esquema de particiones ha cambiado y ya es el que se quería:

[source,shell]
----
lsblk
----

[source]
----
NAME      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
(...)
sda      179:0    0 15,8G  0 disk
├─sda1   179:1    0    1G  0 part
├─sda2   179:2    0    4G  0 part
├─sda3   179:3    0 10,8G  0 part
----

<<<

==== +3e

Una vez preparada la tarjeta para su uso, se puede arrancar el core de Spectrum con una ROM de +3e, y formatear la parte de IDEDOS según se desee.

El primer paso consiste en determinar la geometría de la microSD. Con la tarjeta insertada en el ZXTRES, desde el core de Spectrum con la ROM de +3e, ejecutar el comando:

[source,basic]
----
CAT TAB
----

Esto devoverá un resultado indicando el número de https://es.wikipedia.org/wiki/Cilindro-Cabezal-Sector[cilindros, cabezales y sectores].

Teniendo esto en cuenta, calculamos el espacio que ocupa nuestra partición, en cilindros. Por ejemplo, si el número de cilindros obtenido es de 32768, y queremos utilizar 1GB de una tarjeta de 16GB, el número de cilindros que se necesitarían son 32768/16=2048. Por tanto, podemos formatear la partición IDEDOS usando ese número:

[source,basic]
----
FORMAT TO 0,100,2048
----

El primer valor (`0`) indica el disco a utilizar (el primero), el segundo valor es el número máximo de particiones IDEDOS que se podrán usar, y el tercer valor es el número de cilindros a utilizar.

Una vez hecho el formato, ya será posible crear nuevas particiones. Por ejemplo, para crear una partición llamada "Software" de 16MB, una llamada "Swap1", de 4MB (para usar como espacio swap) y otra llamada "Utils" de 8MB:

[source,basic]
----
NEW DATA "Software",16
NEW EXP "Swap1",4
NEW DATA "Utils",8
----

Para más información sobre el uso de los distintos comandos de +3e para acceso al disco, se puede visitar https://worldofspectrum.org/zxplus3e/espanol/index.html[esta página en World of Spectrum].

<<<

=== Comandos de esxdos

==== Guía básica

Existen dos tipos diferentes de comandos de esxdos, los llamados comandos "DOT", que, como su nombre indica, comienzan por un punto, y las extensiones de la funcionalidad de comandos existentes en BASIC.

Los principales comandos "DOT" commands son los siguientes:

- `128`: Para pasar al modo 128K desde el modo 48K.
- `cd`: Cambiar el directorio actual de trabajo.
- `chmod`: cambiar los atributos de los ficheros de la tarjeta microSD.
- `cp`: Copiar un archivo.
- `divideo`: Reproduce un archivo de vídeo Divideo (.DVO).
- `drives`: Mostrar las unidades disponibles.
- `dskprobe`: Utilidad para ver el contenido a bajo nivel de un dispositivo de almacenamiento.
- `dumpmem`: Permite volcar contenido de la memoria RAM a un fichero.
- `file`: Intenta determinar el tipo de un fichero por su contenido (como el comando de UNIX).
- `gramon`: Monitor para buscar gráficos, sprites, fuentes de texto, etc. en la memoria RAM.
- `hexdump`: Muestra el contenido de un fichero usando notación hexadecimal.
- `hexview`: Permite ver y navegar por el contenido de un fichero usando notación hexadecimal.
- `launcher`: Crea un atajo (launcher) para abrir directamente un fichero TAP.
- `ls`: Ver el contenido de un directorio.
- `lstap`: Ver el contenido de un fichero .TAP
- `mkdir`: Crear un directorio.
- `mktrd`: Crear un fichero imagen de disquete .TRD
- `more`: Ver el contenido de un archivo de texto.
- `mv`: Mover un archivo.
- `partinfo`: Muestra información sobre las particiones de un dispositivo de almacenamiento.
- `playpt3`: Reproducir un archivo musical .PT3.
- `playsqt`: Reproducir un archivo musical .SQT.
- `playstc`: Reproducir un archivo musical .STC.
- `playtfm`: Reproducir un archivo musical .TFC.
- `playwav`: Reproducir un archivo de audio .WAV.
- `rm`: Borrar un archivo o directorio.
- `snapload`: Carga ficheros snapshot.
- `speakcz`: Reproduces texto usando pronunciación checa.
- `tapein`: Montar un archivo .TAP para poder ser utilizado luego desde BASIC con la sentencia LOAD
- `tapeout`: Montar un archivo .TAP para poder ser utilizado luego desde BASIC con la sentencia SAVE
- `vdisk`: Monta una unidad de disquete .TRD para usar en el entorno TR-DOS (Una vez montadas todas las unidades deseadas, se puede entrar en el emulador de TR-DOS escribiendo: `RANDOMIZE USR 15616`)

Algunos comandos extendidos de BASIC son:

- `GO TO` para cambiar de unidad y/o directorio (ej: `GO TO hd1` o `GO TO hd0"juegos"`)
- `CAT` para mostrar el contenido de una unidad
- `LOAD` para cargar un fichero desde una unidad (programa en BASIC, pantalla, código, etc. por ejemplo `LOAD *"Pantalla.scr" SCREEN$`)
- `SAVE` para guardar datos en un fichero (Ej: `SAVE *"Programa.bas"`)
- `ERASE` para borrar un fichero

Además, esxdos incluye un gestor NMI, es decir, una aplicación que se carga cuando se pulsa NMI (F5) y que facilita la navegación por la tarjeta microSD y la carga de algunos tipos de archivo (TAP, Z80, TRD, etc.). Pulsando la tecla "H" se accede a una pantalla de ayuda, en la que se indican todas las teclas disponibles.

[NOTE]
====
El gestor de esxdos muestra las entradas de archivos y directorios en el orden de la tabla FAT interna, y no de manera alfabética. Si se desea ver esta información ordenada, se debe reorganizar la estructura de la tarjeta con una utilidad como FAT Sorter para Windows, https://fatsort.sourceforge.io/[FATsort] para Linux y MacOS, https://www.luisrios.eti.br/public/en_us/projects/yafs/[YAFS], http://www.trustfm.net/software/utilities/SDSorter.phpp[SDSorter] u otros.
====

[CAUTION]
====
En el caso de utilizarse también la tarjeta con un core de PC XT, **no se debe utilizar ninguna utilidad de reordenación de FAT** ya que esto puede provocar que deje de arrancar correctamente DOS en dicho core.
====

<<<

==== Comandos para ZXTRES

Tal y como se ha explicado en la parte de instalación, existe una serie de comandos que son exclusivos para ZXTRES, y que se describen a continuación:

- `back16m`: Copia a un fichero `FLASH.ZX1` en el directorio raíz de la tarjeta microSD el contenido de una memoria SPI Flash de 16 megas. Se debe ejecutar desde una ROM en modo "root". Tras terminar su ejecución hay que ejecutar el comando `.ls` para que se termine de grabar la cache en la tarjeta.
- `backzx2` o `backzxd`: Genera un fichero `FLASH_32.ZX2` o `FLASH_32.ZXD` en el directorio raíz de la tarjeta microSD el contenido de una memoria SPI Flash de 32 megas. Se debe ejecutar desde una ROM en modo "root". Cuando termine hay que ejecutar el comando `.ls` para que se termine de grabar la cache en la tarjeta microSD. Si no se hace, la longitud del archivo se quedará en 0 de forma errónea.
- `corebios`: Para hacer una actualización conjunta del core de ZX Spectrum y de la BIOS.
- `dmaplayw`: Reproduce un archivo de audio .WAV, que debe ser de 8 bits, sin signo y muestreado a 15625 Hz.
- `esprst`: Resetea el módulo WiFi ESP8266(ESP-12).
- `iwconfig`: Configura el módulo WiFi.
- `joyconf`: Configura y prueba los joysticks de teclado y DB9.
- `keymap`: Sirve para cargar una definición de teclado diferente.
- `loadpzx`: Para cargar un archivo de imagen de cinta .PZX.
- `loadtap`: Para cargar un archivo de imagen de cinta usando la integración con .PZX.
- `playmid`: Reproduce archivos musicales .MID en el addon MIDI.
- `playrmov`: Reproduce vídeos en <<#_creación_de_vídeos_rdm_radastan_movie,formato radastaniano (ficheros `.RDM`)>>. Este comando no funciona en modo 48K.
- `romsback`: Copia a un fichero RomPack, llamado `ROMS.ZX1`, en el directorio raíz de la tarjeta microSD todas las ROMS del core ZX Spectrum almacenadas en la memoria SPI Flash. Sólo funciona correctamente en ZX-Uno y ZXDOS (no utilizar en ZXDOS+, ZXTRES o similares). Se debe ejecutar desde una ROM en modo "root".
- `romsupgr`: Copia el contenido de un fichero RomPack, llamado `ROMS.ZX1`, en el directorio raíz de la tarjeta microSD con todas las ROMS para el core ZX Spectrum a la memoria SPI Flash. Se debe ejecutar desde una ROM en modo "root".
- `upgr16m`: Copia el contenido de un fichero `FLASH.ZX1` en el directorio raíz de la tarjeta microSD a una memoria SPI Flash de 16 megas. Se debe ejecutar desde una ROM en modo "root".
- `upgrzx2` o `upgrzxd`: Copia el contenido de un fichero `FLASH_32.ZX2` o `FLASH_32.ZXD` a una memoria SPI Flash de 32 megas.Versión del comando upgrade exclusivo para memorias SPI Flash de 32 Megas. Se debe ejecutar desde una ROM en modo "root".
- `zxuc`: Configura todas las opciones de la BIOS, permitiendo grabar en la microSD las opciones seleccionadas en archivos de configuración que pueden posteriormente ser cargados.
- `zxunocfg`: Configura determinados aspectos del funcionamiento del ZX-Uno como los timings, la contención, el tipo de teclado, la velocidad de la CPU, el tipo y frecuencia vertical del vídeo.

<<<

=== Creación de vídeos RDM (RaDastan Movie)

El comando `PLAYRMOV` reproduce vídeos en formato radastaniano. Para poder convertir nuestros propios vídeos, se debe obtener la utilidad `makevideoradas` desde el https://svn.zxuno.com/svn/zxuno/software/modo_radastan/videos_radastanianos/[Repositorio SVN].

En el caso de Windows, en el propio repositorio hay un ejecutable (`makevideoras.exe`) ya preparado. Para Linux o MacOS, será necesario tener las herramientas de desarrollo correspondientes y compilarlo.

[source,shell]
----
gcc makevideoradas.c -o makevideoradas
----

Una vez dispongamos de `makevideoradas`, necesitaremos otras dos herramientas: https://ffmpeg.org[`ffmpeg`] e https://imagemagick.org/index.php[`imagemagick`]. Estas se pueden instalar con el gestor de paquetes corespondiente (`apt`, `yum`, `pacmam`, `brew`, etc.) o descargando el código fuente y compilándolo también.

Ahora, el primer paso para convertir nuestro vídeo (por ejemplo, `mivideo.mp4`), es exportar los fotogramas como imágenes BMP de 128x96 píxeles de tamaño. Crearemos un directorio temporal (`img` en este ejemplo), donde guardar dichas imágenes.

[source,shell]
----
mkdir img
(...)/ffmpeg -i mivideo.mp4 -vf "scale=128:96,fps=25" -sws_flags lanczos -sws_dither ed -pix_fmt rgb4 -start_number 0 img/output%05d.bmp
----

Ahora transformaremos los ficheros `BMP` a `BMP` (v3) de 16 colores.

[source,shell]
----
(...)/magick mogrify -colors 16 -format bmp -define bmp:format=bmp3 img/*.bmp
----

Finalmente, creamos el fichero `.RDM` (en este ejemplo `mivideo.rdm`) y borramos las imágenes y el directorio temporal.

[source,shell]
----
(...)/makevideoradas img/output
mv img/output.rdm ../mivideo.rdm
rm -rf img
----

En https://www.zonadepruebas.com/viewtopic.php?t=4796&start=110[este hilo del foro Zona de Pruebas] hay más información sobre todo este proceso.

<<<

== Actualizaciones

=== BIOS

Para actualizar BIOS se ha de obtener un fichero llamado `FIRMWARE.ZX3`. La última versión de los ficheros de firmware se puede descargar desde https://github.com/zxdos/zxuno/tree/master/firmware[el repositorio oficial]

[CAUTION]
====
Actualizar el firmware (BIOS) es delicado, no se debe hacer si no es necesario. En el caso de hacerlo, procurar que el ZXTRES tenga alimentación ininterumpida (como un SAI o un USB de portatil con batería).
====

Copiar el fichero en la raíz de la tarjeta MicroSD, encender y pulsar `F2` para entrar en la BIOS, seleccionar `Upgrade`, elegir __"Upgrade BIOS for ZX"__, y luego __"SDfile"__. El sistema leerá el fichero `FIRMWARE...` y avisará cuando esté actualizado.

=== ROMs

La memoria flash del ZXTRES dispone de 64 "slots", de 16K cada uno, para almacenar imágenes ROM de ZX Spectrum y compatibles. Así, la ROM del ZX Spectrum original (16K) ocuparía un slot del almacenamiento, la del ZX Spectrum 128K (32K) ocuparía dos slots, y la del ZX Spectrum +2A (64K) ocuparía 4 slots.

Se puede añadir una nueva ROM desde <<#_roms,la pantalla ROMs>> de la BIOS, pulsando la tecla `N`, conectando un cable de audio a la entrada de sonido de la placa, y reproduciendo una cinta de carga de ROM. Las cintas de carga de ROM se pueden crear desde un archivo `.tap` generado con la utilidad `GenRom`, disponible en el https://github.com/zxdos/zxuno/tree/master/modflash[repositorio de código de ZX-Uno].

Para actualizar las ROM instaladas para ZX Spectrum de forma masiva, se ha de obtener un fichero RomPack con el nombre `ROMS.ZX1`, y se tiene que copiar en la tarjeta MicroSD. Arrancar el ZXTRES usando una ROM en modo "root", y entonces bastará con introducir el comando `.romsupgr`. Esto grabará todas las ROM, que quedarán disponibles para su uso.

[NOTE]
====
Recordar que, si se inicia el ZXTRES pulsando la tecla `/` (del teclado numérico), entonces se cargará la ROM por defecto del core de ZX Spectrum en modo "root".
====

Para hacer el proceso contrario (guardar las ROMs en un fichero RomPack llamado `ROMS.ZX1`), se puede usar el comando `.romsback`.

[NOTE]
====
La versión actual de `romsback`, en ZXTRES, sólo almacena correctamente en RomPack los primeros 35 slots de ROM ocupados.
====

Los ficheros RomPack se pueden editar fácilmente con la utilidad https://guest:zxuno@svn.zxuno.com/svn/zxuno/software/ZX1RomPack/[ZX1RomPack]. Aunque es un programa de Windows, funciona perfectamente, por ejemplo, usando https://www.winehq.org[Wine] o programas similares, tanto en MacOS como en Linux.

=== Cores

Un core consiste en un fichero con la información necesaria para que la FPGA se comporte como el sistema a implementar (ZX Spectrum, etc.). En ZXTRES, este fichero es posible cargarlo desde varios lugares distintos: la memorria SPI Flash, una tarjeta microSD, o desde algún dispositivo externo (PC, etc.) utilizando un cable especial.

==== Tarjeta microSD

===== Carga desde el core de ZX Spectrum

Desde el core principal de ZX Spectrum es posible cargar otros cores 

====== Navegador de Bob Fossil

Para poder utilizar el navegador de Bob Fossil para cargar cores, se necesita lo siguiente:

- La última versión estable (http://www.thefossilrecord.co.uk/wp-content/uploads/zx/BROWSE_latest.zip)
- El plugin ZX3 para poder cargar Cores en formato ZX3 https://github.com/zxdos/zxuno/blob/master/SD/BIN/BPLUGINS/ZX3

Se ha de copiar el fichero `.ZX3` correspondiente en el lugar que se desee de la tarjeta microSD, así como el plugin ZX3 adecuado (en la carpeta `BIN\BPLUGINS``).

. Iniciar el core Spectrum de ZXTRES en modo root (pulsando `/` durante el arranque de la BIOS hasta que se ponga el borde rojo).
. Pulsar `F5` para abrir el navegador de Bob Fossil y navegar hasta la ubicación del Core con extensión `.ZX3`, seleccionarlo y pulsar ENTER.

Si todo va bien, en la parte inferior de la pantalla se indicará el progreso de grabación en la SPI Flash (se graba en un slot temporal).

En el caso de que no se hubiese arrancado en modo root bastará con reiniciar (ctrl+alt+backspace) dejando pulsado "/" y probar de nuevo.

<<<

==== Memoria SPI Flash

Hay 27 espacios de 1MB disponibles para almacenar cores, estando reservados los primeros espacios para el de ZX Spectrum principal (esto no impide tener más cores de ZX Spectrum en otros espacios además de los primeros).

Los cores oficiales están https://github.com/zxtres/cores[disponibles para descargar] en el repositorio en GitHub.

Para actualizar o instalar un nuevo core en la SPI Flash hay varias alternativas.

La primera forma consiste en obtener la última versión de los ficheros que lo definen. Si el tamaño que ocupa es superior a 1179648 bytes, se tendrá que trocear adecuadamente. Cada uno de los trozos será ahora un fichero que hay que llamar `COREXXy.ZX3`, donde XX _siempre_ es un número de dos digitos. La parte `y` del nombre se ignora, así que se pueden usar nombres más largos y descriptivos (como, por ejemplo, `CORE04_ejemplo_parte1.ZX3`).

Copiar los ficheros en la raíz de la tarjeta microSD, encender y pulsar `F2` para entrar en la BIOS. Elegir `Upgrade`, seleccionar la fila correspondiente al número de espacio elegido (por ejemplo, la 4), pulsar enter y luego __"SD file"__. El sistema leerá el fichero `COREnn...` y avisará cuando esté actualizado, aunque antes preguntará el nombre (con el que se verá en la lista para elegir en el arranque y en el listado de la BIOS). Habitualmente, en el caso de cores que ocupan varios espacios se reserva el nombre de core para la primera parte y el resto de partes se registran con un mensaje recordando que no se deben utilizar. Una vez instalado, se podrá utilizar al arrancar, seleccionando siempre el primero de los espacios que use el core.

[WARNING]
====
La actualización del core principal de ZX Spectrum es exactamente igual que los otros cores, pero en lugar del fichero `CORE1.ZX3`, ha de ser un fichero llamado `SPECTRUM.ZX3` con un formato especial para la primera parte.
====

<<<

=== esxdos

Para actualizar esxdos a una nueva versión, se ha de obtener la distribución desde https://www.esxdos.org[la página oficial].

Una vez descargado y descomprimido, se ha de copiar, a la raíz de la tarjeta, el contenido de los directorios `BIN` y `SYS` sobreescribiendo los existentes (para preservar los comandos exclusivos de ZXTRES).

Copiar `ESXMMC.BIN` (o `ESXMMC.ROM`, según la versión) en la raíz de la tarjeta microSD.

Iniciar el ZXTRES con la tarjeta insertada y pulsar F2 para acceder a la configuración de BIOS. Seleccionar el menú `Upgrade` y elegir __"Upgrade esxdos for ZX"__. En el diálogo que aparece elegir __"SD file"__ y, cuando pregunte __"Load from SD"__ contestar __"Yes"__ a la pregunta __"Are you sure?"__. Se leerá el contenido del fichero `ESXDOS...`, se grabará en la flash y avisará cuando esté actualizado.

Realizar un Hard-reset, o apagar y encender.

Si todo se ha hecho correctamente, al encender el ZXTRES se verá cómo esxdos detecta la tarjeta y carga los componentes necesarios para funcionar, mostrando la nueva versión en la parte superior.

=== Memoria Flash

También es posible actualizar la memoria flash de la FPGA. Por el momento desde el menú de la BIOS sólo es posible utilizar imágenes de 16MiB. Para poder usar una imagen de 32MiB, se ha de usar el comando `UPGRZXD` de <<#_esxdos,esxdos>> y un fichero con el nombre `FLASH.ZXD`.

Copiar el archivo de imagen (de 16MiB) `FLASH.ZX3` en la raíz de la tarjeta microSD.

Iniciar el ZXTRES con la tarjeta insertada y pulsar F2 para acceder a la configuración de BIOS. Seleccionar el menú `Upgrade` y elegir __"Upgrade flash from SD"__. En el diálogo que pregunta __"Load from SD"__ contestar __"Yes"__ a la pregunta __"Are you sure?"__. Se leerá el contenido del fichero `FLASH...`, .

Realizar un Hard-reset, o apagar y encender.

[WARNING]
====
Este proceso sustituye todos los cores instalados, la BIOS, así como las ROMs de ZX Spectrum y la configuración por lo que haya en la imagen, y no se puede deshacer.
====

<<<

== Otros cores

=== ColecoVision

https://es.wikipedia.org/wiki/ColecoVision[ColecoVision] es una consola de videojuegos lanzada al mercado por la empresa Coleco.

La versión para ZXTRES está basada en la https://github.com/fbelavenuto/colecofpga[versión para ZX-Uno] de Fabio Belavenuto.

Algunas de las características del core son:

- La ROM de la BIOS se carga desde la tarjeta microSD
- Soporta ROM multicartucho, que también se carga desde la microSD
- Sólo funciona en VGA

==== Formato de Tarjeta microSD

Se debe de utilizar una tarjeta microSD, con la primera partición en formato FAT16 o FAT32, para almacenar los ficheros con las imágenes ROM y otros archivos necesarios. Los archivos se pueden descargar desde la https://github.com/fbelavenuto/colecofpga/tree/master/SD_Card[web del proyecto original en GitHub].

Una vez copiados los ficheros en la tarjeta, se necesita además el fichero `MULTCART.ROM` que se puede obtener en https://t.me/zxtresfpga

Si no estuviera ya, <<#_cores,instalar o ejecutar el core de ColecoVision>> en el ZXTRES.

==== Teclado

===== Teclas especiales y botones

Durante la ejecución del core:

- Cursor o `Q`, `A`, `E`, `R` o el joystick 1: Controles de dirección del jugador 1
- `Z` o el botón de joystick 1: Botón de disparo 1 del jugador 1
- `U`, `J`, `O`, `P` o el joystick 2: Controles de dirección del jugador 2
- `M` o el botón de joystick 2: Botón de disparo 1 del jugador 2
- `X` o el botón secundario de joystick 1: Botón de disparo 2 del jugador 1 y del jugador 2
- `0` a `9`: Botones del 0 al 9 del jugador 1 y el jugador 2
- `T`: Botón '*'
- `Y`: Botón '#'
- 'Esc': Soft Reset

<<<

==== Guía básica

Al iniciar, la ROM de la BIOS se carga desde la tarjeta microSD, así como la ROM multicartucho.

[.text-center]
image:img/coleco.jpg[scaledwidth=70%]

En el menú multicartucho, usar los controles de dirección para elegir la ROM a cargar, y luego el botón de disparo 1 para cargar la ROM elegida. Pulsando `Esc` se reinicia el core y se vuelve a cargar el menú de selección de ROM.

<<<

=== Neo-Geo

https://es.wikipedia.org/wiki/Neo-Geo[Neo-Geo] es el nombre de un sistema de 16 bits basado en cartuchos para arcades así como videoconsolas para el hogar lanzado en 1990 por la compañía de videojuegos japonesa SNK. En un principio el sistema Neo-Geo se creó como plataforma para máquinas recreativas (MVS o Multi Video System), pero más tarde también estuvo disponible como videoconsola doméstica (AES o Advanced Entertainment System).

La versión para ZXTRES (de somhi) está basada en la https://github.com/robinsonb5/NeoGeo_FPGA[versión DeMiStificada] de la https://github.com/MiSTer-devel/NeoGeo_MiSTer[versión original para MiSTer fpga].

Algunas de las características del core son:

- Soporte para MVS y AES
- Soporte para http://unibios.free.fr/download.html[Universe BIOS]
- Compatible con ROMS (no cifradas) en https://wiki.terraonion.com/index.php/Neobuilder_Guide[formato .neo]
- Sólo salida RGB
- Compatible con mandos de MegaDrive

<<<

==== Formato de Tarjeta microSD

Se debe de utilizar una tarjeta microSD, con la primera partición en formato FAT16 o FAT32, para almacenar los ficheros con las imágenes ROM.

Una vez copiados los ficheros en la tarjeta, se necesita una BIOS (por ejemplo http://unibios.free.fr/download.html[Universe BIOS]), con el nombre `neogeo.rom`, en la raíz.

Si no estuviera ya, <<#_cores,instalar o ejecutar el core de Neo-Geo>> en el ZXTRES.

==== Teclado

===== Teclas especiales y botones

Durante la ejecución del core:

- `F12` mostrar el menú de control del core
- Cursor o un mando conectado al puerto izquierdo: Controles de dirección del jugador 1
- `Ctrl Dcha` o el botón A del mando 1: Botón A del jugador 1
- `Alt Dcha` o el botón B del mando 1: Botón B del jugador 1
- `Win Dcha` o el botón C del mando 1: Botón C del jugador 1
- `Mayús. Dcha` o el botón D del mando 1: Botón D del jugador 1
- `Enter`: Botón Start del jugador 1
- `W`, `A`, `S`, `D` o un mando conectado al puerto derecho: Controles de dirección del jugador 2
- `Ctrl Izda` o el botón A del mando 1: Botón A del jugador 2
- `Alt Izda` o el botón B del mando 1: Botón B del jugador 2
- `Win Izda` o el botón C del mando 1: Botón C del jugador 2
- `Mayús. Izda` o el botón D del mando 1: Botón D del jugador 2
- `Bloq. Mayús.`: Botón Start del jugador 2

<<<

==== Guía básica

Si se han copiado los ficheros correctos en la tarjeta microSD y se inicia el core, aparecerá una pantalla en blanco. Al pulsar `F12`, se mostará el menú con las distintas opciones del Core.

[.text-center]
image:img/neogeo.jpg[scaledwidth=70%]

Estas son las principales:

- `Load Cart`: Para cargar desde la tarjeta microSD un fichero .neo
- `Load Cart (skip ADPCM)``
- `Load BIOS``: Para cargar desde la tarjeta microSD un fichero BIOS distinto de `neogeo.rom`
- `Load Memory Card`
- `Save Memory Card`
- `Mount CD`: No disponible por el momento
- `System Type`: MVS o AES
- `CD Speed`: No disponible por el momento
- `CD Region`: No disponible por el momento
- `CD lid`: No disponible por el momento
- `Video Mode`: NTSC o PAL
- `Scanlines`: Para añadir, si se quiere, un efecto de líneas de exploración (scanlines)
- `Blend`: Para activar si se quier, un efecto de suavizado de la imagen
- `Swap Joystick`: Para intercambiar los controles del jugador 1 y el jugador 2
- `Input`: No disponible por el momento
- `[DIP]`: No dispnible por el momento
- `Exit`: Cierra el menú

<<<

=== Test DP

Core alternativo, cuyo objetivo es probar el funcionamiento correcto de las salidas de vídeo VGA, RGB y DisplayPort, aplicando distintos efectos.

Sus características principales son:

- Salida de vídeo DisplaPort
- Salida de vídeo VGA
- Salida de vídeo RGB a 15 kHz (utilizando el puerto VGA)
- Scanlines
- Modos de color fósforo verde, fósforo ambar, escala de grises y color

==== Formato de Tarjeta microSD

Este core no utiliza la tarjeta microSD.

==== Teclado

===== Teclas especiales y botones

Durante la ejecución del core:

- `1`: Hace que la salida VGA cambia a RGB 15 kHz
- `2`: Activa y desactiva scanlines
- `3`: Cambia la pantalla entres los modos de color, fósforo verde, fósforo ambar y escala de grises

[NOTE]
====
Los efectos antes mencionados con las teclas 2 y 3 no se ven en la salida original de 15 kHz.
====

==== Guía básica

Cuando arranca el core, envia señal tanto por VGA como por DisplayPort. La frecuencia de refresco es de unos 64 Hz.

Los tres leds de la placa tienen el siguiente significado:

- El que esta más cerca del borde debe lucir encendido todo el rato. Es el led de DONE, y lo maneja la propia FPGA, no el core.
- El de en medio indica, cuando esta encendido, que hay enlace de transmision valido entre la FPGA y el monitor DisplayPort. Esto significa que el enlace está bien, que el entrenamiento ha sido exitoso, y que en este momento está enviando ya imagen de video al monitor. Si está apagado, significa que no se ha podido establecer el enlace (por ejemplo porque se ha quitado el cable, o está apagado el monitor, o quizás porque no está la entrada DisplayPort seleccionada en dicho monitor).
- El del otro extremo debe lucir parpadeando, a razón de un parpadeo por segundo mas o menos. Es un "latido" del reloj de pixel que indica que tanto la salida VGA como la DisplayPort estan generando imagen. Si este led no parpadea, no se podrá ver imagen de ningun tipo ni por VGA ni por DisplayPort, tan sólo por RGB a 15 kHz. En circunstancias normales, tanto si hay enchufado un monitor DisplayPort como si no, este led debería estar parpadeando.

<<<

=== ZX81

El computador personal https://es.wikipedia.org/wiki/ZX81[Sinclair ZX81], lanzado por Sinclair Research en 1981, fue el de menor precio de la época.

La versión para ZXTRES ha sido creada por avlixa, basada en la página de Grant Searle's sobre el ZX80

Características:

- Se puede elegir entre ZX80 y ZX81 (ZX80 sólo con salida RGB por el momento)
- 16k/32k/48k RAM packs
- 8KB con addon CHR$128/UDG (sin probar)
- QS CHRS (sin probar)
- CHROMA81
- Turbo en modo lento: NoWait, x2, x8
- Chip de sonido YM2149 (compatible con ZON X-81)
- Múltiples joysticks (Cursor, Sinclar, ZX81, ZXpand)
- Timings PAL y NTSC
- Turbo carga de ficheros .o y .p
- Carga de ROM alternativa
- Carga de programas a través de la entrada de audio

==== Formato de Tarjeta microSD

Se debe de utilizar una tarjeta microSD, con la primera partición en formato FAT16 o FAT32, para almacenar los ficheros con archivos de cinta o ROM que se deseen cargar.

Se puede copiar, si se desea, un fichero `ZX8X.ROM` (disponible the https://github.com/avlixa/ZX81_MiSTer_zxdos/raw/master/roms/zx8x.rom[repositorio oficial] en el directorio `/zx81/roms`: se trata de los ficheros ZX81 rom (8k) + ZX80 rom (4k) concatenados.

Si no estuviera ya, <<#_cores,instalar o ejecutar el core de ZX81>> en el ZXTRES.

<<<

==== Teclado

El teclado no está mapeado a la distribución PS/2 estándar, y mantiene la distribución de la máquina original. Así, por ejemplo, para obtener `"` se ha de pulsar `Mayús+P` o para borrar, `Mayús+0`.

**ZX80**

[.text-center]
image:img/keyboardZX80.jpg[scaledwidth=80%]

**ZX81**

[.text-center]
image:img/keyboardZX81.jpg[scaledwidth=80%]

===== Teclas especiales y botones

Durante la ejecución del core:

- `F1`: Habilitar o deshabilitar los caracteres alternativos
- `F5` o el botón 2 del joystick para mostrar u ocultar el menú.
- `F9`: Deshabilita o habilita la salida MIC al conector de audio, porque algunos juegos generan un ruido molesto
- `F10`: Habilita o deshabilita sonido de entrada por la salida de audio, para escuchar la cinta si se carga por audio
- `Bloq. Despl.`: para cambiar entre modo de vídeo RGB y VGA
- `Ctrl+Alt+Supr`: Reset
- `Ctrl+Alt+Backspace`: Hard reset.

<<<

==== Guía básica

Pulsando `F5` o el botón 2 del joystick se muestra el menú de configuración. Se usan las teclas de cursor y `Enter` para elegir y seleccionar opciones del menú.

[.text-center]
image:img/zx81.jpg[scaledwidth=70%]

En él se pueden activar, desactivar o configurar las siguientes opciones:

- Reiniciar el core (Reset)
- Cargar un archivo de cinta (Load Tape)
- Cargar una ROM alternativa (Load ROM)
- Configurar opciones (Configuration Options)
- Salir del menú (Exit)

<<<

[.text-center]
image:img/zx81_2.jpg[scaledwidth=70%]

- Elegir el modelo de computador (Computer Model): ZX80/ZX81
- Tamaño de RAM (Main RAM): 16K/32K
- RAM baja (Low RAM): Off/8KB
- Joystick: Cursor/Sinclair/ZX81
- Habilitar o deshabilitar QS CHRS
- Configuración de CHR$128/UDG: 128 chars/64 chars/Disabled
- Habilitar o deshabilitar Chroma81: Disabled/Enabled
- Vídeo inverso (Inverse Video): Off/On
- Borde negro (Black Border): Off/On
- Modo de velocidad (Slow mode speed): Original/No Wait/x2
- Frecuencia de vídeo (Video frequency): 50Hz/60Hz

Desde BASIC, se puede cargar desde un fichero cinta, que se haya seleccionado desde el menú, con el comando `LOAD""` y pulsando `Enter`.

[TIP]
====
Algunos monitores dejan de reproducir la entrada de audio si se desactiva la señal de vídeo. Se recomienda conectar unos auriculares o altavoces externos para poder oir el sonido durante la carga de una cinta.
====

Se pueden cargar archivos `.p` con color y caracteres alternativos.

Para que funcione el coloreado, se debe activar CHROMA81 antes de la carga. Igualmente, para los caracteres alternativos, QS CHRS debería estar activo antes de cargar.

[TIP]
====
Las opciones recomendadas para la mayoría de los juegos son:

Main RAM: 16KB
Low RAM: 8KB
CHR$128: 128 chars
QS CHRS: enabled
CHROMA81: enabled
====

<<<

=== zxsp

<<<

== Otro Hardware

=== Carga desde cinta

Para algunos cores como, por ejemplo, el de Spectrum o el de MSX, es posible cargar, igual que se hacía en las máquinas originales, desde un dispositivo externo de audio como un reproductor de cassette u otro que lo simule.

Normalmente, se debe utilizar un cable adecuado para la <<#_puertos_y_conectores,entrada de sonido del ZXTRES>>, concretamente, ha de ser un cable con un jack estéreo de 3,5 mm en un extremo dos salidas mono en el otro (una para cada canal de audio), conectando el extremo del canal mono derecho al dispositivo de reproducción de cintas (esto no es necesario en Miniduino, ya que este automáticamente utiliza sólo el canal derecho de sonido al reproducir).

==== Reproductor de cassette

El funcionamiento es exactamente igual que se hacía con los equipos originales:

. Conectar el cable de audio
. Ejecutar en el equipo o elegir la opción correspondiente a la carga desde cinta. Por ejemplo, en ZX Spectrum 48K, pulsando `J`, a continuación, dos veces, `"` y luego `Enter` para ejecutar el clásico `LOAD "" + Enter`
. Iniciar la reproducción de la cinta (es posible que haya que hacer distintos intentos ajustando el volumen del reproductor)

==== Ordenador

Según el sistema operativo (Windows, MacOS, Linux) existen múltiples alternativas de programas que pueden, o bien reproducir directamente un archivo de cinta (`TAP`, `TZX`, `PZX`, etc.) y emitir el sonido por la salida de auriculares, o bien crear un fichero de sonido (`WAV`, `VOC`, `AU`, etc.) que se puede reproducir también con programas de música o sonido.

===== PlayTZX

Este programa para Windows, MacOS o Linux, permite reproducir un fichero de cinta `TZX` a través de la salida de sonido del ordenador.

Se puede descargar el fichero binario (por ejemplo, para Windows desde https://worldofspectrum.net/utilities/#tzxtools[World of Spectrum Classic] y para Mac desde https://github.com/kounch/playtzx/releases[este repositorio de GitHub]) o compilar el código fuente como se explica <<#_compilar_código_fuente_macos_o_linux,a continuación>>.

. Conectar el cable de audio entre la salida del ordenador y la entrada de audio del ZXTRES (recordar conectar únicamente el extremo del canal mono derecho al extremo del PC/Mac, etc.)
. Ejecutar en el equipo o elegir la opción correspondiente a la carga desde cinta. Por ejemplo, en ZX Spectrum 48K pulsando `J` a continuación, dos veces, `"` y luego `Enter` para ejecutar el clásico `LOAD "" + Enter`

<<<

[start=3]
. Iniciar la reproducción de un fichero de cinta con el siguiente comando (es posible que haya que hacer distintos intentos ajustando el volumen de salida del equipo)

[source,shell]
----
./playtzx <fichero de cinta>
----

Si todo va bien, se irá viendo en la consola los distintos bloque de carga de la cinta, mientras el sonido se produce y el core del ZXTRES carga el programa.

[TIP]
====
En Linux, el programa utiliza como salida el dispositivo `/dev/dsp`, así que, en versiones más modernas, es posible, por ejemplo, que haya que cargar módulos como `snd_pcm_oss` (en el caso de sistemas que utilicen ALSA), para que funcione correctamente.
====

====== Compilar código fuente (MacOS o Linux)

Verificar que están instaladas las herramientas de desarrollo, incluyendo un compilador de C (`gcc`, `clang` herramientas de desarrollaor de línea de comandos en Mac, etc.) y https://es.wikipedia.org/wiki/GNU_build_system[GNU Autotools].

Descargar el código fuente https://github.com/kounch/playtzx[desde este repositorio]), descomprimirlo y acceder en una consola al directorio, y ejecutar los comandos:

[source,shell]
----
aclocal && autoconf && autoheader && automake --add-missing
./configure
make
----

Si todo se ha hecho correctamente, se habrá generado el fichero `playtzx` que se puede copiar a donde se desee en el disco duro y utilizar. Se puede borrar el directorio descomprimido donde se compiló.

==== Teléfono móvil, tableta, reproductor de sonido MP3, etc.

En general, existen muy pocas alternativas (o ninguna) alternativas de programas que puedan reproducir directamente un archivo de cinta en un dispositivo móvil, así que, normalmente, será necesario convertir a un fichero de audio el contenido de la cinta antes de intentar cargarla con uno de estos aparatos.

https://github.com/semack/zx_tape_player[ZX Tape Player] es una App para sistemas iOS y Android que es capaz de reproducir directamente a través de la salida de auriculares

https://play.google.com/store/apps/details?id=com.baltazarstudios.playzxtapes[PlayZX] es otra App similar, pero sólo para sistemas Android.

[WARNING]
====
Los dispositivos con salida de auriculares modernos, suelen estar pensados para manejar impedancias el orden de unas pocas decenas de ohmios. Esto, a veces, puede ser insuficiente para la entrada del ZXTRES.

En esos casos, se recomienda (si es posible) desactivar las limitaciones de volumen máximo de auriculares y/o utilizar un dispositivo amplificador de auriculares, que eleve la impedancia.
====

Los pasos a seguir en este caso son:

. Conectar el cable de audio entre la salida del dispositivo móvil y la entrada de audio del ZXTRES (recordar conectar únicamente el extremo del canal mono derecho al extremo del PC/Mac, etc.)
. Ejecutar en el equipo o elegir la opción correspondiente a la carga desde cinta. Por ejemplo, en ZX Spectrum 48K pulsando `J` a continuación, dos veces, `"` y luego `Enter` para ejecutar el clásico `LOAD "" + Enter`
. Iniciar la reproducción del fichero de audio (o del fichero de cinta en el caso de PlayZX). Es posible que haya que hacer distintos intentos ajustando el volumen del reproductor/amplificador.

===== Conversión a fichero de audio

A continuación se indican algunos de los muchos programas que existen para distintos sistemas operativos, y que pueden exportar ficheros de cinta a ficheros de audio.

https://www.alessandrogrussu.it/tapir/index.html[Tapir] es un programa con interfaz gráfica para Windows (pero que se puede usar también con Wine en Linux o Mac) que permite cargar ficheros `TZX` y `TAP` y exportarlos como `WAV` de audio

`tape2wav` de https://fuse-emulator.sourceforge.net/[Fuse Utilities] es una utilidad de línea de comandos que exporta desde ficheros `TZX` `PZX` y `TAP` a `WAV`. Disponibles para muchos sistemas operativos distintos.

`pzx2wav` en http://zxds.raxoft.cz/pzx.html[PZX Tools] es otra utilidad de comandos que exporta desde ficheros `PZX` a `WAV`. Disponible como ejecutable para Windows, y con el código fuente disponible para compilar en otros sistemas.

<<<

==== Miniduino

include::miniduino_es.adoc[leveloffset=+3]

<<<

== Solución de problemas

=== Gestión de imágenes de firmware

Existen distintas herramientas que permiten generar y/o editar el contenido de los ficheros `ZX1`, `ZX3`.

==== zx123_tool

Esta es una herramienta que analiza, extrae o añade datos en ficheros de imagen de SPI flash de ZX-Uno, ZXDOS, ZXTRES y otros dispostivos similares.

Para poder utilizarla se necesita https://www.python.org/[Python 3]. Según el sistema operativo que se utilice puede que sea necesario https://www.python.org/downloads/[instalarlo].

Teniendo Python 3, basta con descargar la última versión de la herramienta desde su repositorio oficial, https://github.com/kounch/zx123_tool/releases/latest[en este enlace].

Una vez descomprimido, se debe invocar desde una consola el script principal usando Python 3. Esto puede variar según el sistema operativo.

Por ejemplo, en Windows, suele ser:

[source,shell]
----
py -3 zx123_tool.py
----

Mientras que en otros sistemas operativos debería bastar con algo parecido a:

[source,shell]
----
python3 ./zx123_tool.py
----

También hará falta un archivo de imagen flash. Este se puede obtener desde el core de Spectrum, en modo "root", con alguno de los comandos `back16m`, `backzx2` o `backzxd`. Tras obtener el fichero generado en la microSD, se puede "limpiar" dejando sólo el core de Spectrum y la primera ROM de Spectrum con un comando similar a este:

[source,shell]
----
... zx123_tool.py -i FLASH.ZXD -w -o FLASHempty.ZXD
----

Donde `FLASH.ZXD` es la ruta al fichero obtenido desde el core de Spectrum, y `FLASHempty.ZXD` es la ruta al nuevo fichero "limpio".

<<<

*Mostrar contenido de una imagen*

Para ver el contenido de una imagen llamada `FLASH.ZXD` (cores instalados y algunos datos de configuración), se puede usar el comando

[source,shell]
----
... zx123_tool.py -i FLASH.ZXD -l
----

Para mostrar contenido de esa misma imagen, incluyendo datos de ROMs de ZX Spectrum:

[source,shell]
----
... zx123_tool.py -i FLASH.ZXD -l -r
----

*Modificar la BIOS de una imagen*

Para modificar la BIOS de un fichero llamado `FLASH.ZXD`, usando la BIOS en otro fichero llamado `FIRMWARE.ZXD`

[source,shell]
----
...zx123_tool.py -i FLASH.ZXD -a BIOS,FIRMWARE.ZXD
----

Además de instalar la BIOS, se pueden modificar algunos de los valores por defecto. Por ejemplo, con las opciones; `-m` para el modo de vídeo: 0 (PAL), 1 (NTSC) ó 2 (VGA), `-k` para la distribución del teclado: 0 (Auto), 1 (ES), 2 (EN) ó 3 (Spectrum).

Así, para modificar la BIOS de un fichero llamado `FLASH.ZXD`, usando la BIOS en otro fichero llamado `FIRMWARE.ZXD`, y además configurar el modo de vídeo en VGA:

[source,shell]
----
...zx123_tool.py -i FLASH.ZXD -a BIOS,FIRMWARE.ZXD -m 2 -k 3
----

Existen también opciones para ajustar el tiempo de espera inicial de la BIOS, el core a ejecutar por defecto, o la ROM de Spectrum a utilizar por defecto. Véase la https://github.com/kounch/zx123_tool/#castellano[documentación de la herramienta] para más información.

<<<

*Añadir una ROM de Spectrum a una imagen*

Para añadir una ROM de Spectrum llamada `48.rom`, poniendo el nombre `Spec48` y ocupando el slot 5, se puede usar un comando como:

[source,shell]
----
...zx123_tool.py -i FLASH.ZXD -a ROM,5,xdnlh17,Spec48,48.rom
----

Véase la https://github.com/kounch/zx123_tool/#castellano[documentación de la herramienta] para ver todas las posibles opciones a la hora de añadir una ROM de Spectrum.

Entre los datos que se indican al añadir una ROM, hay una serie de indicadores para definir qué opciones de hardware, etc. se desean habilitar o deshabilitar al cargar esa ROM en concreto, según se puede ver en esta tabla:

[align="center",width="70%",%header,cols=2*]
|===
|`i`
|Habilitar teclado issue 3 (en vez de issue 2)
|`c`
|Deshabilitar la contención de memoria
|`d`
|Habilitar DivMMC
|`n`
|Habilitar NMI DivMMC (menú de esxdos)
|`p`
|Usar timings de Pentagon
|`t`
|Usar timings de 128K
|`s`
|Deshabilitar puertos de DivMMC y ZXMMC
|`m`
|Habilitar MMU horizontal de Timex
|`h`
|Deshabilitar bit alto de ROM (bitd 2 de 1FFD)
|`l`
|Deshabilitar bit bajo de ROM (bit 4 de 7FFD)
|`1`
|Deshabilitar puerto 1FFD (paginado de +2A/3)
|`7`
|Deshabilitar puerto 7FFD (paginado de 128K)
|`2`
|Deshabilitar TurboSound (chip AY secundario)
|`a`
|Deshabilitar chip AY
|`r`
|Deshabilitar modo Radastaniano
|`x`
|Deshabilitar modo Timex
|`u`
|Deshabilitar ULAPlus
|===

<<<

*Instalar un Core en una imagen*

Para instalar un core en la posición 3, desde un fichero llamado `NEXT.ZXD`, llamándolo `Spectrum Next`, usar un comando como este:

[source,shell]
----
...zx123_tool.py -i FLASH.ZXD -a 'CORE,3,Spectrum Next,NEXT.ZXD'
----

Si además se quiere configurar como el core por defecto, se puede indicar también con un comando como:

[source,shell]
----
...zx123_tool.py -i FLASH.ZXD -a 'CORE,3,Spectrum Next,NEXT.ZXD' -c 3
----

*Modificar la ROM de esxdos de una imagen*

De forma similar a como se instala el firmware de la BIOS, se puede instalar directamente un fichero con la ROM de esxdos, con un comando como:

[source,shell]
----
...zx123_tool.py -i FLASH.ZXD -a esxdos,ESXMMC.BIN
----

*Combinar varias órdenes en una única línea*

Notar que se pueden acumular varias órdenes en una única línea de comandos. Por ejemplo, para "limpiar" un archivo de imagen llamado `FLASH.ZXD`, creando uno nuevo llamado `FLASHnew.ZXD`, instalar la BIOS desde el fichero `FIRMWARE.ZXD`, configurar el modo de vídeo en VGA, añadir una ROM de Spectrum llamada `48.rom`, poniendo el nombre `Spec48` y ocupando el slot 5, instalar un core en la posición 3, desde un fichero llamado `NEXT.ZXD`, llamándolo `Spectrum Next`, configurado como el core por defecto, usar un comando como este:

[source,shell]
----
... zx123_tool.py -i FLASH.ZXD -w -o FLASHnew.ZXD -a BIOS,FIRMWARE.ZXD -m 2 -k 3 -a ROM,5,xdnlh17,Spec48,48.rom -a 'CORE,3,Spectrum Next,NEXT.ZXD' -c 3
----

<<<

<<<

=== Recuperación del firmware

En algunos casos (por ejemplo al instalar un core experimental o hacer una actualización del core de ZX Spectrum o la BIOS) puede suceder que el ZXTRES deje de arrancar. Se encienden los LEDs pero no hay imagen ni responde a las distintas combinaciones de teclado para acceder a la BIOS, etc.

En esta situación, existen diferentes métodos de recuperación que permiten volver a instalar el firmware.

==== Preparación del cableado

En los siguientes pasos de recuperación se habla de conectar cables puente o USB-Blaster a la placa de ZXTRES. Para ello, usar la siguiente imagen como referencia.

[.text-center]
image:img/jtagzxtres.jpg[scaledwidth=80%]

[WARNING]
====
*NO* se ha de conectar la línea de 3V
====

<<<

==== Recuperación usando una Raspberry Pi

*Material necesario*:

- Raspberry Pi (con tarjeta SD, teclado, monitor, fuente de alimentación, etc.) y con conexión a internet
- 5 https://es.wikipedia.org/wiki/Cable_puente[cables puente para prototipos] (idealmente, hembra en los dos extremos) y, opcionalmente, un adaptador USB-Blaster
- Un destornillador de estrella adecuado
- Tarjeta SD para el ZXTRES con la primera partición en formato FAT16 o FAT32
- Teclado y monitor para conectar el ZXTRES

*Software necesario*:

- Imagen Flash y recovery para ZXTRES, del https://github.com/zxtres/cores/tree/main/recovery[repositorio principal de Github]. Notar que existe un fichero distinto para cada tipo de dispositivo:
** `recovery_a35.bit` para ZXTRES
** `recovery_a100.bit` para ZXTRES+
** `recovery_a200.bit` para ZXTRES++

*Pasos a seguir*:

. Si no estuviera ya, instalar Raspberry Pi OS (antes llamado Raspbian) en la Raspberry Pi (usando https://www.raspberrypi.org/downloads/raspberry-pi-os/[la descarga oficial], https://www.raspberrypi.org/downloads/noobs/[NOOBS], https://github.com/procount/pinn[PINN], etc.)
. Instalar Open OCD en la Raspberry Pi:

[source,shell]
----
sudo apt-get update
**sudo apt-get install git autoconf libtool make pkg-config
sudo apt-get install libusb-1.0-0 libusb-1.0-0-dev telnet
sudo apt-get install libusb-dev libftdi-dev
git clone git://git.code.sf.net/p/openocd/code openocd-code
cd openocd-code/
./bootstrap
./configure --enable-usb_blaster --enable-sysfsgpio --enable-bcm2835gpio
make
sudo make install
cd ..
rm -rf ./openocd-code
----

<<<

[start=3]
. Conectar el USB-Blaster o los cables puente para GPIO <<#_preparación_del_cableado,tal y como se explica anteriormente>>. Si se va a hacer la conexión usando GPIO, abrir la carcasa del ZXTRES y conectar las líneas de JTAG de la FPGA (`TMS`, `TDI`, `TDO`, `TCK` y `GND`), con los cables, a los pines https://es.wikipedia.org/wiki/GPIO[GPIO] de la Raspberry Pi.

Si se hace conexión vía GPIO, tomar nota de los pines elegidos, teniendo cuidado de conectar `GND` con `GND`.

[.text-center]
image:img/gpio.jpg[scaledwidth=70%]

En este ejemplo, se utilizarán los pines `31`, `33`, `35`, `37` y `39` (correspondientes a `GPIO #6`, `GPIO #13`, `GPIO #19`, `GPIO #26` y `GND`), de la siguiente manera:

[%header,cols=3*]
|===
|JTAG ZXTRES
|GPIO
|Pin Raspberry Pi
|`TMS`
|GPIO#6
|`31`
|`TDI`
|GPIO#13
|`33`
|`TDO`
|GPIO#19
|`35`
|`TCK`
|GPIO#26
|`37`
|`GND`
|GND
|`39`
|===

[start=4]
. Copiar en la Raspberry Pi el fichero `recovery_axx.bit` obtenido anteriormente del https://github.com/zxtres/cores/tree/main/recovery[repositorio principal de Github]. En nuestro ejemplo, se dejará en `/home/pi/zxtres/unbrick/`

<<<

[start=5]
. Para la conexión usando GPIO, realizar una copia del archivo de configuración de Open OCD, en el mismo lugar donde está `recovery.bit`. Este paso no es necesario si se usa USB-Blaster.

[source,shell]
----
cp /usr/local/share/openocd/scripts/interface/raspberrypi2-native.cfg /home/pi/zxtres/unbrick/
----

[start=6]
. Para la conexión vía GPIO, editar la copia de `raspberrypi2-native.cfg` actualizando `bcm2835gpio_jtag_nums` (y descomentando, si fuera necesario), según como se haya hecho la conexión entre JTAG y GPIO en la línea `bcm2835gpio_jtag_nums`. En nuestro ejemplo:

[source]
----
# Header pin numbers: 37 31 33 35
bcm2835gpio_jtag_nums 26 6 13 19
----

[start=7]
. Comentar, si no lo está, la línea `bcm2835gpio_swd_nums` (de nuevo, no necesario si la conexión es con USB-Blaster):

[source]
----
#bcm2835gpio_swd_nums 11 25
----

[start=8]
. Añadir, al final, la línea `adapter speed 250` (no necesario para uso con USB-Blaster):

[source]
----
adapter speed 250
----

[start=9]
. Encender el ZXTRES

. Asegurarnos de que estamos en el directorio donde se encuentra el archivo `recovery_axx.bit`, y lanzar el comando que carga la BIOS en modo recuperación, indicando, si fuera necesario, la ruta al archivo `raspberrypi2-native.cfg` que habíamos editado anteriormente

Para conexión vía GPIO:

[source,shell]
----
cd /home/pi/zxtres/unbrick
sudo openocd -f /home/pi/zxtres/unbrick/raspberrypi2-native.cfg -f /home/pi/zxtres/unbrick/xilinx-xc7.cfg -c "init; pld load 0 recovery_axx.bit; shutdown"
----

Con USB-Blaster:

[source,shell]
----
cd /home/pi/zxtres/unbrick
sudo openocd -f /usr/local/share/openocd/scripts/interface/altera-usb-blaster.cfg -f /home/pi/zxtres/unbrick/xilinx-xc7.cfg -c "init; pld load 0 recovery_axx.bit; shutdown"
----

[TIP]
====
Recordar reemplazar en los comandos anteriores `recovery_axx.bit` por el nombre del fichero adecuado para la placa a recuperar.
====

[start=11]
. Si todo va bien, veremos cómo cambia el estado de los LED de la FPGA y veremos la imagen de la BIOS en el monitor.

En el caso de que no se vea imagen, y si no se está utilizando DisplayPort, pulsar `Bloq. Despl.`: para cambiar entre modo de video compuesto y VGA, por si acaso la BIOS ha arrancado en un modo que no corresponde a la conexión del monitor.

[.text-center]
image:img/recovery.png[scaledwidth=70%]

[start=12]
. Insertar en el ZXTRES la tarjeta SD con la primera partición en formato FAT16 o FAT32, y en la que habremos copiado el fichero `FLASH.ZX3` descargado anteriormente.

. Si se está utilizando USB-Blaster, desconectar el cable.

<<<

[start=14]
. Elegir la opción `Upgrade Flash from SD`. Pulsar Enter, elegir `Yes`, y pulsar Enter de nuevo para comenzar el proceso que graba de nuevo la Flash.

[.text-center]
image:img/recovery2.png[scaledwidth=70%]

[WARNING]
====
Este proceso sustituirá todos los cores instalados, la BIOS, así como las ROMs de ZX Spectrum y la configuración por lo que haya en la imagen, y no se puede deshacer.
====

[start=15]
. Tras unos minutos, el proceso finalizará, y podremos comprobar como, al apagar y encender, el ZXTRES vuelve a arrancar correctamente.

[NOTE]
====
Si no se obtiene imagen, y no se está utilizando DisplayPort, pulsar de nuevo `Bloq. Despl.` para cambiar entre modo de video compuesto y VGA. En este caso, sería necesario acceder a la BIOS y cambiar el <<#_advanced, ajuste avanzado correspondiente>> para indicar la configuración de nuestro monitor.
====

<<<

== Referencias

=== Scan Codes

[.text-center]
image:img/scancodes.png[scaledwidth=80%]

<<<

=== Enlaces

https://zxuno.speccy.org/index.shtml[ZX-Uno]

http://desubikado.sytes.net/zx-uno-faq-version-desubikado/[ZX-Uno FAQ]

https://docs.google.com/document/d/1NI0zgCDRk7c-5CVi-lfZEK6q8Lnpnco7PhpsEEdxD60/edit[Guía rápida del ZX-Uno]

https://www.zxuno.com/wiki/index.php/ZX_Spectrum[Core ZX Spectrum]

https://worldofspectrum.org/zxplus3e/index.html[The ZX Spectrum +3e Homepage]

https://worldofspectrum.org/zxplus3e/sharingdisks.html[Sharing a +3e disk with PC (FAT) partitions]

https://www.zxuno.com/forum/viewtopic.php?f=37&t=208[Layouts de teclado]

https://github.com/spark2k06/zxunops2/blob/master/Alternative/Nuevo%20firmware%20de%20teclado%20ZX-GO%2B.pdf[Firmware de teclado para ZX Go+]

https://github.com/zxdos/zxdos-plus/tree/master/zxunops2[zxunops2]

https://docs.google.com/spreadsheets/d/17-ifpHcy932_AP7SAv9uBLxg-2ZptcdgTvQ8ILXQLM4/htmlview[Almost (In-) Complete List of esxDOS DOT-Commands]

https://www.va-de-retro.com/foros/viewtopic.php?t=1718&start=10#p25076[Cargando Leches 2.0]

http://retrowiki.es/viewtopic.php?f=83&t=200032578&p=200075671&hilit=wifi#p200075671[WiFi (RetroWiki)]

https://www.zxuno.com/forum/viewtopic.php?f=35&t=44[WiFi en ZX-Uno]

https://svn.zxuno.com/svn/zxuno/cores/spectrum_v2_spartan6/test19_multi_uart/[Core de ZX-Uno Test UART (WiFi)]

https://nihirash.net/network-tools-for-zx-uno-pack/[Network tools for ZX-Uno pack]

https://www.espressif.com/sites/default/files/documentation/4a-esp8266_at_instruction_set_en.pdf[ESP8266 AT Instruction Set]

https://www.zonadepruebas.com/viewtopic.php?t=4796&start=110[Vídeos Radastanianos]

https://www.zxuno.com/forum/viewtopic.php?f=52&t=4074&p=28234&hilit=kyp#p28234[Nuevo core zx48]

https://github.com/rcmolina/MaxDuino_BETA/blob/master/MANUAL%20por%20desUBIKado/MAXDUINO%20Gu%C3%ADa%20de%20uso.pdf[Maxduino - guía de uso]
