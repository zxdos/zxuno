= ZXTRES ZXTRES+ and ZXTRES++ Manual
:author: kounch
:editor: aowendev
:revnumber: 1.0.0
:doctype: book
:notitle:
:front-cover-image: image:img/portada_zxtres.jpg[]
:email: kounch@users.noreply.github.com
:Revision: 1.0
:description: ZXTRES Manual (Hiberno-English)
:keywords: Manual, English, ZXTRES, ZXTRES+, ZXTRES++
:icons: font
:source-highlighter: rouge
:toc: left
:toc-title: Index
:toclevels: 4

<<<

== Introduction

The ZXTRES, ZXTRES+ and ZXTRES++ are a continuation of the https://zxuno.speccy.org[ZX-Uno] hardware and software project created by Superfo, AVillena, McLeod, Quest and Hark0. The ZX-Uno team created an FPGA board programmed to behave like a ZX Spectrum computer.

Over time the project grew and it's now possible to use different software configurations (cores) that work like different systems other than the ZX Spectrum. You can choose to start the ZXTRES with your desired configuration from all those available.

The ZXTRES official web page is https://www.forofpga.es/viewforum.php?f=251[https://www.forofpga.es/viewforum.php?f=251].

Most of the functions and features of the ZXTRES, ZXTRES+ and ZXTRES++ are the same, so this document typically refers to the ZXTRES indicating the differences when necessary. In this document, _controller_ means joystick or gamepad. Buttons are labelled alphabetically from `A` but labels on individual controllers may differ. 

=== Acknowledgements

Much of the content of this manual is based on information previously shared at:

- https://www.forofpga.es/[foroFPGA].
- https://www.zxuno.com/forum/[ZX-Uno forum].
- Several existing FAQs; mostly the original version https://uto.speccy.org/zxunofaq.html[by @uto_dev] and the latest one http://desubikado.sytes.net/zx-uno-faq-version-desubikado/[by @desUBIKado].
- the official Telegram channels for https://t.me/zxuno[ZX-Uno] https://t.me/zxdosfpga[ZXDOS] and https://t.me/zxtresfpga[ZXTRES].
- https://github.com/zxtres/wiki/wiki[ZXTRES official wiki].

Without the previous work of all these people (and more) this manual wouldn't exist.

<<<

=== Ports and connectors

[.text-center]
image:img/ZXTRESfront.jpg[scaledwidth=90%]

[align="center",width="80%",cols="1,4"]
|===
|1
|Left controller port
|2
|microSD card Slot
|3
|Right controller port
|4
|Power socket
|5
|Power switch
|6
|PS/2 keyboard port
|7
|PS/2 mouse port
|===

<<<

[.text-center]
image:img/ZXTRESback.jpg[scaledwidth=90%]

[align="center",width="80%",cols="1,4"]
|===
|8
|Audio in
|9
|Audio out
|10
|USB port (only for use with for <<#_middle_board,middle board>> installed)
|11
|RGB/VGA out
|12
|JTAG access
|13
|Expansion port
|14
|DisplayPort out
|===

[.text-center]
image:img/ZXTRESbottom.jpg[scaledwidth=90%]

[align="center",width="80%",cols="1,4"]
|===
|15
|BOOTSEL button for <<#_middle_board,middle board>>
|16
|Sound selection switch (https://en.wikipedia.org/wiki/Delta-sigma_modulation[Sigma-Delta] or https://en.wikipedia.org/wiki/I²S[I^2^S])
|===

<<<

=== Initial setup

To set up and use the ZXTRES you need at least:

- DisplayPort, VGA or RGB cable and compatible display (the RGB connection can also be used with a VGA to SCART adapter and connected to compatible TVs).
- PS/2 keyboard
- USB charger, TV or other device that provides USB power (5VDC and at least 1A). The connector is a coaxial jack "barrel" plug of 5.5mm outer diameter and 2.1mm inner diameter with positive polarity (centre positive)

[TIP]
====
It's important that the source has stable voltage and sufficient current or erratic behaviour may occur (the keyboard or DisplayPort may fail and so on). Some keyboards or peripherals may require a similar power supply but with 2A or more.

[.text-center]
image:img/powerConnector.png[scaledwidth=20%]
====

To take advantage of its full potential you may also need:

- Atari standard controller such as a Sega Mega Drive (Gensis) controller.
- Audio cable with a stereo 3.5mm jack on one side and both audio channels split into two mono outputs on the other side if you want to use an audio player or recorder such as a Miniduino (<<#_miniduino,see more information later>>), a modern computer or a https://en.wikipedia.org/wiki/Cassette_tape[cassette tape recorder]. The right sound channel is used as input (EAR) and the left channel can be used as output (MIC).
- microSD card with 32GB capacity or less.
- PS/2 mouse.
- Speakers to connect to the audio output or a stereo jack converter to two red and white RCA connectors to connect to a TV,

[NOTE]
====
If an active VGA to https://en.wikipedia.org/wiki/SCART[SCART] adapter is connected, it will use some free pins of the VGA port to transmit audio, but only when there is nothing connected to the 3.5 mm jack audio output port.
====

<<<

==== microSD card formatting

This table shows the requirements of cores that use the microSD card.

[align="center",width="100%",%header,cols="4a,1a,1a,1a,3a,2a,4a,5a",options="header"]
|===
|[.small]#Core#|[.small]#FAT16#|[.small]#FAT32#|[.small]#+3e#|[.small]#Primary Partition Type#|[.small]#Extra Partitions#|[.small]#Access#|[.small]#Notes#
|[.small]#Amiga#|[.small]#No#|[.small]#Sí#|[.small]#No#|[.small]#Any#|[.small]#No#|[.small]#ROMs, disk images#|[.small]#Requires ROM#
|[.small]#Amstrad CPC#|[.small]#No#|[.small]#No#|[.small]#No#|[.small]#None#|[.small]#No#||[.small]#Doesn't use the SD#
|[.small]#Atari 2600#|[.small]#Yes#|[.small]#Yes#|[.small]#No#|[.small]#Any#|[.small]#No#|[.small]#Only ROMs (`.BIN`)#|
|[.small]#ColecoVision#|[.small]#Yes#|[.small]#Yes#|[.small]#No#|[.small]#Any#|[.small]#No#|[.small]#Only ROMs (`ROM`)#|
|[.small]#Enterprise#|[.small]#Yes#|[.small]#Yes#|[.small]#No#|[.small]#Any#|[.small]#No#|[.small]#Disk Images (`VHD`)#|[.small]#Requires ROM#
|[.small]#Jupiter ACE#|[.small]#No#|[.small]#No#|[.small]#No#|[.small]#None#|[.small]#No#||[.small]#Doesn't use the SD#
|[.small]#Neo-Geo#|[.small]#Yes#|[.small]#Yes#|[.small]#No#|[.small]#Any#|[.small]#No#|[.small]#Only ROMs (`NEO`)#|[.small]#Requires BIOS#
|[.small]#ZX81#|[.small]#Yes#|[.small]#Yes#|[.small]#No#|[.small]#Any#|[.small]#No#|[.small]#Only images (`O` and `P`)#|
|[.small]#zxp3#|[.small]#Yes#|[.small]#Yes#|[.small]#Yes#|[.small]#Any#|[.small]#No#|[.small]#Disk Images (`VHD`)#|[.small]#Requires ROM#
|[.small]#ZX Spectrum EXP#|[.small]#Yes#|[.small]#Yes#|[.small]#Yes#|[.small]#Any#|[.small]#Yes#|[.small]#Full#|[.small]#Using SPI Flash esxdos#
|[.small]#ZX Spectrum Next#|[.small]#Yes#|[.small]#Yes#|[.small]#No#|[.small]#Any#|[.small]#Yes#|[.small]#Full#|[.small]#Can read esxdos ROM from microSD#
|===

[NOTE]
====
FAT16 partitions have a maximum size of 4GB.
====

[CAUTION]
====
When naming a partition to be used with esxDOS you can't also use it as a folder name on that partitio. Otherwise an error occurs when trying to access the contents (don't name the partition as `BIN` `SYS` or `TMP`).
====

[TIP]
====
The ZX Spectrum core can also have <<#_microsd_advanced_format_3e,the first partition in +3DOS format and then the second one in FAT16 or FAT32 format>> to use with the +3e ROM.
====

<<<

===== Windows

For simple configuration of microSD cards of the correct size (2GB or less for FAT16 or 32GB or less for FAT32) you can use https://www.sdcard.org/downloads/formatter/[the official formatting tool of the SD Association].

For other more complex configurations and depending on operating system version you can use the command line tool `diskpart` or the Windows Disk Management GUI.

For example, to format a microSD card shown as disk 6 when executing `list disk` from `diskpart` with only one FAT16 partition (if the microSD card size is less than 4GB):

[source]
----
select disk 6
clean
create part primary
active
format FS=FAT label=ZXTRES
exit
----

To create two FAT16 partitions (for example to use MSX core) and have the rest of space as another FAT32 partition (for microSD cards more than 8GB in size):

[source]
----
select disk 6
clean
create part primary size=4000
set id = 06
active
format fs=FAT label=ZXTRES quick
create part primary size=4000
format fs=FAT label=EXTRA quick
create part primary
format fs=FAT32 label=DATA quick
exit
----

To create one FAT32 4GB partition (for example to use with Amstrad CPC 6128 core) and then have the rest of space available as a second FAT32 partition (for microSD cards more than 4GB in size):

[source]
----
select disk 6
clean
create part primary size=4000
set id = 0b
active
format fs=FAT32 label=ZXTRES unit=4k quick
create part primary
format fs=FAT32 label=EXTRA quick
exit
----

<<<

===== macOS

For simple configuration of microSD cards of the correct size (2GB or less for FAT16 or 32GB or less for FAT32) you can use https://www.sdcard.org/downloads/formatter/[the official formatting tool of the SD Association] or Disk Utility which is included with the operating system.

In other case you should use the command line.

For example, to format a microSD card shown as `disk6` with only one FAT16 partition (if the microSD card size is less than 2GB):

[source,shell]
----
diskutil unmountDisk /dev/disk6
diskutil partitionDisk /dev/disk6 MBR "MS-DOS FAT16" ZXTRES R
----

To split it into two FAT16 partitions of the same size (if the microSD card size is 4GB or less):

[source,shell]
----
diskutil unmountDisk /dev/disk6
diskutil partitionDisk /dev/disk6 MBR "MS-DOS FAT16" ZXTRES 50% "MS-DOS FAT16" EXTRA 50%
----

To create two FAT16 partitions (for example to use MSX core) and have the rest of space as another FAT32 partition (for microSD cards more than 8GB in size):

[source,shell]
----
diskutil unmountDisk /dev/disk6
diskutil partitionDisk /dev/disk6 MBR %DOS_FAT_16% ZXTRES 4G %DOS_FAT_16% EXTRA 4G "MS-DOS FAT32" DATA R
sudo newfs_msdos -F 16 -v ZXTRES -c 128 /dev/rdisk6s1
sudo newfs_msdos -F 16 -v EXTRA -b 4096 -c 128 /dev/rdisk6s2
----

[NOTE]
====
`diskutil` can't create FAT16 partitions that are bigger than 2GB and then format them. That's why in this example you must format them only after creating the partitions.
====

<<<

To create one FAT32 4GB partition (for example to use with the Amstrad CPC 6128 core) and then make the rest of space available as a second FAT32 partition (for microSD cards of more than 4GB):

[source,shell]
----
diskutil unmountDisk /dev/disk6
diskutil partitionDisk /dev/disk6 MBR "MS-DOS FAT32" ZXTRES 4G "MS-DOS FAT32" EXTRA R
----

[NOTE]
====
In this example because the partition has a size of exactly 4GB, macOS uses a cluster size of 4096 bytes which is the one required for the Amstrad CPC 6128 core. For a smaller size you may need to format the first partition again. For example:

[source,shell]
----
diskutil unmountDisk /dev/disk6
newfs_msdos -F 32 -v ZXTRES -b 4096 /dev/rdisk6s1
----
====

[TIP]
====
The Spotlight feature in macOS enables you to search the items on the microSD card creating a number of hidden files. You can switch off the indexing with these commands (assuming that the SD partition is called `ZXTRES`):

[source,shell]
----
mdutil -i off /Volumes/ZXTRES
cd /Volumes/ZXTRES
rm -rf .{,_.}{fseventsd,Spotlight-V\*,Trashes}
mkdir .fseventsd
touch .fseventsd/no_log .metadata_never_index .Trashes
cd -
----
====

<<<

===== Linux

There are many tools for Linux that can format or partition a microSD card (`fdisk` `parted` `cfdisk` `sfdisk` or `GParted` to name a few). Note that the partition scheme must always be MBR and the first partition (the one to be used for esxDOS) must be the primary partition.

For example to format a microSD card shown as `sdc` with only one FAT16 partition (if the microSD card size is less than 4GB):

[source,shell]
----
sudo fdisk --compatibility=dos /dev/sdc
----

[source]
----
(...)
Command (m for help): n
Partition type
   p   primary (0 primary, 0 extended, 4 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (1-4, default 1): 1
First sector (62-31116288, default 62):
Last sector, +/-sectors or +/-size{K,M,G,T,P} (128-31116288, default 31116288):
Created a new partition 1 of type 'Linux'

Command (m for help): t
Selected partition 1
Hex code (type L to list all codes): 6
Changed type of partition 'Linux' to 'FAT16'.

Command (m for help): a
Partition number (1, default 1): 1
The bootable flag on partition 1 is enabled now.

Command (m for help): p
Disk /dev/sdc
Disklabel type: dos
Disk identifier

Device     Boot   Start     End  Sectors   Size Id Type
/dev/sdc1           62 31116288  31116288 984,9M 6 FAT16
----

Format a FAT partition (requires root permission):

[source,shell]
----
sudo mkfs.fat -F 16 -n ZXTRES -s 128 /dev/sdc1
----

<<<

=== Keyboard

==== PS/2 keyboard

The keyboard map (physical keys of the keyboard assignment to the keystrokes that are presented to the different cores) is changed using the `Advanced` menu of the BIOS. There are three different maps to choose from: Spanish (default), English and Spectrum (advanced).

You can also change it using the `keymap` utility. Inside `/bin` you can create a folder called `keymaps` and copy the keyboard map files that you want to use inside it. For example to switch to the US map, enter `.keymap us` from esxDOS.

For the map to be preserved after a hard reset it must be selected as `Default` in the BIOS.

For more information see https://www.zxuno.com/forum/viewtopic.php?f=37&t=208[this message in the ZX-Uno forum].

Note, <<#_se_basic_iv>> uses its own native system to set the keyboard map and has its own https://github.com/source-solutions/sebasic4/wiki/Keyboard-layouts[layouts].

==== English

[.text-center]
image:./img/keyboardEng.png[scaledwidth=70%]

==== Spanish

[.text-center]
image:./img/keyboardEsp.png[scaledwidth=70%]

==== Spectrum

[.text-center]
image:./img/keyboardAv.png[scaledwidth=70%]

<<<

==== Special keys and buttons

Special keys that can be used during startup:

- `Esc` or controller button `B` (if a controller with two or more buttons is connected): ZX Spectrum core ROM selection menu.
- `F2`: Enter BIOS setup.
- `1` to `9`: Load the core in the flash location corresponding to that number. On the latest BIOS versions `9` is used to load the core installed to the temporary slot used by the <<#_bob_fossil_nmi_browser,ZX3 plugin>>.
- `R`: Load the ZX Spectrum core ROM in "real" mode; switching off esxDOS, new graphics modes and so on.
- `Caps Lock`, `Cursor Down` or controller `down` (if connected): Core selection menu.

Special keys that can be used while running the main core (ZX Spectrum):

- `Esc`: Break.
- `F2`: Edit.
- `F5`: NMI.
- `F7`: Play or pause when playing `PZX` files.
- `F8`: Rewind a `PZX` file to the previous mark.
- `F10`: Graph(ics).
- `F12`: Turbo boost (speeds up CPU to 28 MHz).
- `Ctrl+Alt+Backspace`: Hard reset (restart the FPGA). Backspace is the delete key located in the top-right portion of the keyboard above `Enter`.
- `Ctrl+Alt+Supr`: Soft reset (restart the core).
- `Scroll Lock`: Switches between RGB and VGA video modes. DisplayPort is always enabled.
- `Home`: Switches between the several DisplayPort deinterlacing modes (Blend Off Auto and On). This option is only available for ZXTRES+ and ZXTRES++ core versions.
- `End`: Select one of the monochrome colour modes.

<<<

=== esxDOS

https://esxdos.org/index.html[esxDOS] is a firmware for the divIDE/divMMC hardware interfaces (that ZXTRES implements). This enables access to storage devices such as a microSD card. It includes commands similar to those of UNIX although to use them you must precede them with a dot (`.`) for example `.ls`, `.cd`, `.mv` and so on.

For it to work it's necessary to include the corresponding files in the first partition of the microSD card.

At the time of writing this document the version included with ZXTRES is 0.8.9 and it can be downloaded from the https://www.esxdos.org/files/esxdos086.zip[official website].

After you've downloaded and extracted the `ZIP` archive, you must copy the folders `BIN`, `SYS` and `TMP` and all their contents to the root of first partition of the microSD card.

If everything was done correctly, when you start the ZX Spectrum core you'll see esxDOS detect the microSD card and load the required components to work.

[.text-center]
image:./img/esxdos.png[scaledwidth=70%]

<<<

You should add the ZXTRES-specific esxDOS commands. These can be obtained from the project source page (https://github.com/zxtres/dot_commands/[here], https://github.com/zxdos/zxuno/tree/master/SD/BIN[here] and https://guest:zxuno@svn.zxuno.com/svn/zxuno/software/upgrade[here]):

    back16m
    backzx2
    backzxd
    core
    corebios
    dmaplayw
    esprst
    iwconfig
    joyconf
    keymap
    loadpzx
    loadtap
    playmid
    playrmov
    romsupgr
    upgr16m
    upgrzx2
    upgrzxd
    zxuc
    zxunocfg

<<_#_zxtres_commands,It's explained later>> what each of these commands does.

<<<

=== BIOS

[.text-center]
image:./img/boot_zxtres.png[scaledwidth=80%]

Press the `F2` key during boot to access the BIOS setup. The BIOS firmware is the first program that runs when the ZXTRES is powered on. The main purpose of BIOS is to start and test the hardware and load one of the installed cores.

Using left and right cursor keys you can navigate through the BIOS setup screens. With up and down keys you can choose the different elements of each screen. With the `Enter` key you can activate and choose the options for each of these. The `Esc` key is used to close open option windows without applying any action.

Other special keys that can be used during startup:

- `Esc` or controller button `B` (if a controller with two or more buttons is connected): ZX Spectrum core ROM selection menu.
- `F2` Enter BIOS setup.
- `1` to `9`: Load the core in the flash location corresponding to that number.  On the latest BIOS versions `9` is used to load the core installed to the temporary slot used by the <<#_bob_fossil_nmi_browser,ZX3 plugin>>.
- `Caps Lock` or `Cursor down` or controller `down` (if connected): Core selection menu.
- `R`: Load the ZX Spectrum core ROM in "real" mode, switching off esxDOS, new graphics modes and so on.

<<<

==== Main

[.text-center]
image:img/bios.png[scaledwidth=70%]

From the _Main_ screen you can run several tests and define the default behaviour for:

- Boot Timer: Sets how long the boot screen is available (or hiding it completely).
- Check CRC: Check ROM integrity when loading (more secure) or bypassing it (faster).
- Keyboard: Set keyboard map.
- Timing: ULA Behaviour (48K, 128K or Pentagon).
- Contended: Set lower RAM contention (on or off).
- DivMMC: Enable or switch of divMMC.
- NMI-DivMMC: Enable or swtich off divMMC NMI support (used by the NMI browser).
- New Graphic Modes: (ULAplus, Timex, Radastan).

More technical information can be found at the https://www.zxuno.com/wiki/index.php/ZX_Spectrum[ZX-Uno Wiki].

<<<

==== ROMs

[.text-center]
image:img/bios2.png[scaledwidth=70%]

The _ROMs_ screen shows the installed ZX Spectrum core ROMs. You can reorder (move up or move down), rename or remove each of them. You can also choose the one that is loaded by default at startup (Set Active ).

==== Upgrade

[.text-center]
image:img/bios3_zxtres.png[scaledwidth=70%]

The _Upgrade_ screen is used to perform updates to the Flash memory content; esxDOS, BIOS, cores and so on. For more information, see the <<#_upgrade,section corresponding to upgrades>>.

<<<

==== Boot

[.text-center]
image:img/bios4_zxtres.png[scaledwidth=70%]

In the _Boot_ screen you can choose which of the installed cores is loaded by default at startup.

<<<

==== Advanced

[.text-center]
image:img/bios5_zxtres.png[scaledwidth=70%]

From the _Advanced_ screen you can configure:

- Keyboard layout (Keyb Layout): For more informaiton, see <<#_keyboard,the corresponding section>>.
- Controller behaviour connected to the right port (DE9) and also the emulated controller using the numeric keypad (Joy Keypad): Kempston, Sinclair 1, Sinclair 2, Protek, Fuller or simulate the keys `Q`,` A` `O`,` P` `Space` and `M`.
- behaviour of a controller connected to the left port (DE9): Kempston, Sinclair 1, Sinclair 2, Protek, Fuller or simulate the keys `Q`,` A` `O`,` P` `Space` and `M`.
- Video output: PAL, NTSC or VGA (DisplayPort is always active).
- Scanline simulation: enabled or switched off.
- VGA horizontal frequency: 50, 51 and so on.
- CPU speed: Normal (1X) or accelerated (2X, 3X and so on).
- Csync: Spectrum or PAL.

<<<

==== Exit

[.text-center]
image:img/bios6.png[scaledwidth=70%]

From the _Exit_ screen you can:

- Exit BIOS configuration saving changes (in some cases a power cycle is also required).
- Discard changes and exit.
- Save changes without exiting.
- Discard changes.

== ZX Spectrum

The main core is the one implementing a ZX Spectrum computer. This core is special and can't be replaced with another that's not a ZX Spectrum because the ZXTRES uses it for its operation.

Some of its main characteristics include:

- ZX Spectrum 48K, 128K, +3, Pentagon and Chloe 280SE implementation.
- ULA with ULAplus, Timex and Radastanian modes (including hardware scroll and selectable palette group).
- Memory contention select (for Pentagon 128 compatibility).
- Keyboard behaviour select (issue 2 or issue 3).
- ULA timing select (48K, 128K or Pentagon).
- Control of screen framing configurable for type of timing and possibility to choose between original Spectrum synchronisms or progressive PAL standard.
- Timex horizontal MMU support with HOME, DOC and EX banks in RAM.
- Programmable raster interrupt on any TV line.
- Memory bank management register select for better compatibility with each implemented model.
- Activate or deactivate the devices incorporated into the core to improve compatibility with certain programs.
- ZXMMC and divMMC support for +3e, esxDOS and compatible firmwares (such as UnoDOS 3).
- TurboSound-AY support.
- SpecDrum support.
- Each channel (A, B and C) of the two AY-3-8912, beeper and SpecDrum chips can be directed to the left, right, both or neither outputs enabling the implementation of configurations such as ACB, ABC and so on.
- Real controller and keyboard-emulated controller support with Kempston, Sinclair 1 and 2, Cursor, Fuller and QAOPSpcM protocol.
- Turbo mode support at 7 MHz, 14 MHz and 28 MHz.
- Keyboard support (PS/2 protocol) and user-configurable mapping from within the ZX Spectrum core itself.
- PS/2 mouse support emulating the Kempston Mouse protocol.
- Video output in RGB 15 kHz, VGA and DisplayPort.
- User selectable vertical refresh rate to improve compatibility with VGA monitors.
- Multicore boot support: from the ZX Spectrum core you can select an address of the SPI Flash and the FPGA will load a core from there.
- Different colour modes including monochrome.
- https://en.wikipedia.org/wiki/I²S[I^2^S] and https://en.wikipedia.org/wiki/Delta-sigma_modulation[Sigma-Delta] audio output.
- Wi-fi Support (UART) using the middle board.
- MIDI Support (General MIDI) using the middle board.
- RTC Support using the middle board.
- `PZX` file loading from microSD card emulating tape audio.
- Multiple deinterlacing modes for DisplayPort including an option to blend the colours. This is only available for ZXTRES+ and ZXTRES++ core versions.

<<<

=== ROMs

The ZX Spectrum core can be initialized using different ROM versions (48K, 128K, +2 and so on). These are stored in the flash memory of the ZXTRES and you can choose which one to load by pressing the `Esc` key during boot. You can also define the ROM that you want to load by default using the BIOS setup.

For more information on how to expand or modify the ROMs stored in flash memory, see the <<#_roms_3,updates section>>.

==== DerbyPro

https://www.facebook.com/groups/DerbyPro[DerbyPro or Derby{pp}] is an enhanced firmware ROM for the ZX Spectrum based on v1.4 of the Derby development ROM. The Spectrum 128 (codename "Derby") was a Spanish machine commissioned by Investronica and launched in 1985. It came with a keypad that provided additional editing keys. In 1986 the UK version came out with a simplified version of 128 BASIC and no keypad. Derby++ is developed from the Spanish ROM to include the benefits of both versions without the drawbacks and support for new hardware developments.

[.text-center]
image:img/derbypro.png[pdfwidth=70%]

<<<

Features include:

- 100% binary compatible 48K mode.
- 6-channel PLAY commmand.
- Access the esxDOS NMI browser from the boot menu.
- Debugged 128 BASIC with additinoal commands and full scren string editor.
- esxDOS support in 128 BASIC.
- Menu access to TR-DOS.
- PALETTE command for ULAplus.
- Run most Spectrum software without the need to switch configuration in the BIOS.

You can download the ROM, a user manual and other files from the https://www.facebook.com/groups/DerbyPro[official Facebook Public Group].

Because it's a 64K ROM with support for new hardware these flags can be used when <<#_zx123_tool,adding it to the SPI flash>>:

[align="center",width="60%",%header,cols=2*]
|===
|Flag
|Meaning
|`d`
|Enable divMMC
|`n`
|Enable NMI divMMC (esxDOS Menu)
|`t`
|Use 128K timings
|===

<<<

==== CargandoLeches

CargandoLeches is a set of ZX Spectrum ROMs that started as a project to load games in any Spectrum model 15 to 20 times faster. No tape is needed but a digital audio source such as a computer, mobile device, MP3 player and so on is required. The new ROM detects the loading method and reverts to the original ROM code if required. This is handled transparently with no user or program intervention.

From version 2.0 the project changed from a single ROM to more; each one with different options. This way you can choose a different mix of options that may include:

- Enable or switch off Sinclair BASIC token expansion.
- POKE editor.
- Reset & Play (After a sofware reset of the core the system is ready to load from tape).
- Ultrafast loading.

The whole ROM set is available to download from the repository in GitHub https://github.com/antoniovillena/CargandoLeches/tree/master/binaries[here].

Depending on which ROM you choose the flags when <<#_zx123_tool,adding to the SPI flash>> may vary. For example, for the ROM `48le_ea_re_po` (with all features enabled) these flags can be used (you can't enable NMI-DivMMC because the POKE editor uses the NMI):

[align="center",width="60%",%header,cols=2*]
|===
|Flag
|Meaning
|`d`
|Enable divMMC
|`h`
|Switch off ROM high bit (1FFD bit 2)
|`l`
|Switch off ROM low bit (7FFD bit 4)
|`x`
|Switch off Timex mode
|===

===== POKEs

When using a ROM with POKE option enabled:

. After the game is loaded, press `F5` (NMI button). A dialog is displayed in the upper left corner of the screen
. Enter the POKE address and press `Enter`.
. Enter the POKE value and press `Enter` again.
. Repeat steps 2 and 3 until all desired POKEs are entered. To finish and return to the game press `Enter` twice.

<<<

===== Preparing ultrafast loading tapes

The ROMs with ultrafast loading enabled need special tape audio data that is made from normal loading `TAP` files without protections or turbo loading.

To create an ultrafast loading tape you need the `leches` and `CgLeches` command line utilities. Those can be obtained for Windows from the
https://github.com/antoniovillena/CargandoLeches/tree/master/binaries[official repository]. You can also obtain an unofficial version for macOS from https://github.com/kounch/CargandoLeches/tree/master/binaries/macOS[this other repository].

Otherwise you can compile from the https://github.com/antoniovillena/CargandoLeches[source code at the official repository]. For example, in Linux to compile using `gcc` you only need these commands:

[source,shell]
----
gcc leches.c -o leches
gcc CgLeches.c -o CgLeches
----

To create an ultrafast loading tape you must use the `CgLeches` command from a terminal giving at least the path to the original `TAP` file and the new file to create (`WAV` or `TZX`). There are also some other optional parameters such as the loading speed between 0 and 7 (where 0 is fastest but also more incompatible), if you want to create a mono or stereo file (when making a `WAV`) and more.

To make a `WAV` file with an ultrafast loading tape from the file `Valley.tap` with loading speed 5 you could enter:

[source,shell]
----
(...) CgLeches Valley.tap Valley.wav 5
----

This way the file `Valley.wav` can be played from a computer or another device and load using the ROM (see the section about <<#_loading_from_tape,loading from tape>> for more info).

[WARNING]
====
Due to hardware limitations, `TZX` files made with `CgLeches` don't work with a <<#_miniduino,Miniduino>> although they usually work with <<#_playtzx,`PlayTZX`>>.
====

<<<

==== SE Basic IV

https://source-solutions.github.io/sebasic4/[SE Basic IV] is a free open-source BASIC interpreter for the Z80 architecture. Although it aims for a high degree of compatibility with Microsoft BASIC, there are some differences. It's designed to run on the https://www.patreon.com/chloe280se[Chloe 280SE] but it's also compatible with the ZX Spectrum core of the ZXTRES.

SE BASIC began development in 1999 as the firmware for the https://sinclair.wiki.zxnet.co.uk/wiki/ZX_Spectrum_SE[ZX Spectrum SE], the ancestor of the Chloe 280SE. Early versions were patches applied to the original Spectrum ROM. From version 1, it used its own assembly file. From version 2, it added support for ULAplus.

Version 3 (https://zxdesign.itch.io/opense[OpenSE BASIC]) replaced the original ROM code with an open source version derived from the https://github.com/cheveron/open81[ZX81] and  https://github.com/cheveron/samrom[SAM Coupé] ROMs. It's still maintained as an open source replacement firmware for the Spectrum, and is included in the main https://tracker.debian.org/pkg/opense-basic[Debian repository] for use with emulators.

[.text-center]
image:img/sebasic4.png[pdfwidth=70%]

Version 4.0 added support for 80 column mode. Version 4.1 was an unsuccessful attempt to refactor the code. Starting in 2019, the latest version (4.2 Cordelia) was rebuilt from the ground up to take full advantage of the ZX Spectrum core of the ZX-Uno (and ZXTRES). While earlier versions retained a high level of compatibility with Sinclair BASIC and software, this version has no support for Sinclair software and is closer in dialect to Atari BASIC.

Version 4.2 requires that divMMC support is enabled with esxDOS or UnoDOS 3 installed. However, <<#_esxdos_commands,"dot" command >> commands and the NMI browser are not supported.

<<<

Features include:

- 40 column (16 colour) and 80 column (2 colour) paletted video modes.
- Always-on expression evaluation (use variables as filenames).
- Application package format with support for turning BASIC programs into apps.
- Automatic data typing.
- Bitwise logic (AND, NOT, OR, XOR).
- Built-in help system.
- Choice of Microsoft (LEFT$, MID$, RIGHT$) or Sinclair (TO) string slicing.
- Composable characters (supports Vietnamese).
- Disk-based filesystem (no tapes).
- Error handling (ON ERROR..., TRACE).
- Flow control (IF...THEN...ELSE, WHILE...WEND).
- Full random file access from BASIC (OPEN, CLOSE, SEEK).
- Full-size keyboard support (DEL, HOME, END and so on).
- Graphics commands in 40 column mode (CIRCLE, DRAW, PLOT).
- Localisation of character sets, error messages, and keyboard layouts.
- Long variable names.
- Motorola style number entry (%; binary, @; octal, $; hexadecimal).
- NMI BREAK.
- On-entry syntax checking.
- PLAY command with 6-channel PSG and MIDI support.
- Recursive user-defined functions.
- Smart firmware updates.
- Token abbreviation and shortcuts (&; AND, ~; NOT; |; OR, ?; PRINT, '; REM').
- Undo NEW (OLD).
- User-defined channels.
- User-defined character sets (256 characters).
- User-defined macros.
- User-defined screen modes.

[NOTE]
====
For the smart firmware update option to work, SE Basic IV must be installed in the second and third 16K ROM slots.
====

[CAUTION]
====
Using the smart firmware update feature replaces the version of esxDOS you're using with the latest version of UnoDOS 3.
====

<<<

==== Other ROMs

Here are flag settings that work when <<#_zx123_tool,adding to the SPI flash>> some other known custom ROMs:

[align="center",width="60%",%header,cols=2*]
|===
|ROM Name
|Flags
|Arcade Game Designer 0.1
|thl17x
|Gosh Wonderful ROM v1.33
|dnhl17x
|Looking Glass 1.07
|dnhl17x
|ZX82 by Daniel A. Nagy
|dnhl17
|ZX85 by Daniel A. Nagy
|dntmh1

|===

<<<

=== microSD advanced format (+3e)

The ZX Spectrum +3e ROM can be used with the ZX Spectrum core. This is an improved Sinclair ZX Spectrum +3 ROM that can use microSD cards and other media.

The +3e uses its own partition format (called IDEDOS) to split the hard disk into several partitions to store data. ROM version 1.28 and later can share IDEDOS partitions with MBR partitions. Otherwise you must reserve the whole microSD card for the IDEDOS partitions.

[IMPORTANT]
====
This partition scheme can only be used with the ZX Spectrum core.
====

[TIP]
====
Each partition in IDEDOS can be between 1 and 16MB (16 million bytes) in size and each disk can have between 1 and 65535 partitions. This means that the maximum space used in a microSD card is about 1TB.
====

This is one method to split a microSD card into two or three parts with the first partition IDEDOS (1GB) the second one FAT16 (4GB) and the third one FAT32 (using the remaining space in the microSD card).

exsDOS and other programs can be installed into the second partition <<#_esxdos,as explained earlier>>.

==== Windows

You can use Windows Disk Management utility. The steps are:

. Remove all partitions from the microSD card.

. Create a new extended partition using the desired space for IDEDOS.

. Create a primary partition 4GB in size and format as FAT16.

. Optionally create another primary partition using the remaining space and format as FAT32.

<<<

==== macOS

You need to use the command line. The first task is to find out which device is the disk to format:

[source,shell]
----
diskutil list
----

For this example it's disk 6:

[source]
----
(...)
/dev/disk6 (external, physical):
   #:                       TYPE NAME                    SIZE       IDENTIFIER
   0:     FDisk_partition_scheme                        *15.9 GB    disk6
   1:                 DOS_FAT_32 UNKNOWN                 15.9 GB    disk6s1
----

Instruction steps:

. Unmount the disk and edit the partition sceme (the second step requires admin privileges):

[source,shell]
----
diskutil unmountDisk /dev/disk6
sudo fdisk -e /dev/rdisk6
----

[source]
----
fdisk: could not open MBR file /usr/standalone/i386/boot0: No such file or directory
Enter 'help' for information
fdisk: 1> erase
fdisk:*1> edit 1
Partition id ('0' to switch off)  [0 - FF]: [0] (? for help) 7F
Do you wish to edit in CHS mode? [n]
Partition offset [0 - 31116288]: [63] 128
Partition size [1 - 31116287]: [31116287] 2017152

fdisk:*1> edit 2
Partition id ('0' to switch off)  [0 - FF]: [0] (? for help) 06
Do you wish to edit in CHS mode? [n]
Partition offset [0 - 31116288]: [2017280]
Partition size [1 - 29099135]: [29099135] 7812504

fdisk:*1> flag 2
----

[source]
----
fdisk:*1> edit 3
Partition id ('0' to switch off)  [0 - FF]: [0] (? for help) 0B
Do you wish to edit in CHS mode? [n]
Partition offset [0 - 31116288]: [9829784]
Partition size [1 - 21286504]: [21286504]

fdisk:*1> print
         Starting       Ending
 #: id  cyl  hd sec -  cyl  hd sec [     start -       size]
------------------------------------------------------------------------
 1: 7F 1023 254  63 - 1023 254  63 [       128 -    2017152] <Unknown ID>
 2: 06 1023 254  63 - 1023 254  63 [   2017280 -    7812504] DOS > 32MB
 3: 0B 1023 254  63 - 1023 254  63 [   9829784 -   21286504] Win95 FAT-32
 4: 00    0   0   0 -    0   0   0 [         0 -          0] unused

fdisk:*1> write
fdisk: 1> quit
----

[start=2]
. Format the FAT partitions (admin privileges required):

[source,shell]
----
diskutil unmountDisk /dev/disk6
sudo newfs_msdos -F 16 -v ZXTRES -c 128 /dev/rdisk6s2
sudo newfs_msdos -F 32 -v EXTRA -c 128 /dev/rdisk6s3
----

[start=3]
. Confirm that the new partition scheme was applied:

[source,shell]
----
diskutil list
----

[source]
----
(...)
/dev/disk6 (external, physical):
   #:                       TYPE NAME                    SIZE       IDENTIFIER
   0:     FDisk_partition_scheme                        *15.9 GB    disk6
   1:                       0x7F                         1.0 GB     disk6s1
   2:                 DOS_FAT_16 ZXTRES               4.0 GB     disk6s2
   3:                 DOS_FAT_32 EXTRA                   10.9 GB    disk6s3
----

<<<

==== Linux

You can use the command line. First find out the device to erase:

[source,shell]
----
lsblk
----

For this example it's `sdc`:

[source]
----
NAME         MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
(..)
sdc          179:0    0 15,8G  0 disk
└─sdc1       179:1    0 15,8G  0 part
----

Instructions:

. Verify that the disk isn't mounted and edit the partition scheme (this step requires root privileges):

[source,shell]
----
sudo fdisk --compatibility=dos /dev/sdc
----

[source]
----
Welcome to fdisk
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Command (m for help): n
Partition type
   p   primary (0 primary, 0 extended, 4 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (1-4, default 1): 1
First sector (62-31116288, default 62): 128
Last sector, +/-sectors or +/-size{K,M,G,T,P} (128-31116288, default 31116288): 2017152

Created a new partition 1 of type 'Linux'

Command (m for help): t
Selected partition 1
Hex code (type L to list all codes): 7f
Changed type of partition 'Linux' to 'unknown'.

Command (m for help): n
Partition type
   p   primary (1 primary, 0 extended, 3 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (2-4, default 2):
First sector (45-31116288, default 45): 2017280     .
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2017153-31116288, default 31116288): 7812504

Created a new partition 2 of type 'Linux'

Command (m for help): t
Partition number (1,2, default 2): 2
Hex code (type L to list all codes): 6

Changed type of partition 'Linux' to 'FAT16'.

Command (m for help): a
Partition number (1,2, default 2): 2

The bootable flag on partition 2 is enabled now.

Command (m for help): n
Partition type
   p   primary (2 primary, 0 extended, 2 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (3-4, default 3): 3
First sector (45-31116288, default 45): 9829784     .
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2017153-31116288, default 31116288): 31116288

Created a new partition 3 of type 'Linux'

Command (m for help): t
Partition number (1-4, default 3): 3
Hex code (type L to list all codes): b

Changed type of partition 'Linux' to 'W95 FAT32'.

Command (m for help): p
Disk /dev/sdc
Disklabel type: dos
Disk identifier

Device     Boot   Start     End  Sectors   Size Id Type
/dev/sdc1           128 2017152  2017025 984,9M 7f unknown
/dev/sdc2  *    2017280 7626751  7812504   2,7G  b FAT16
/dev/sdc3       9829784 7626751 21286504    21G  b W95 FAT32
----

[start=2]
. Format both FAT partitions (requires root privileges):

[source,shell]
----
sudo mkfs.fat -F 16 -n ZXTRES -s 128 /dev/sdc2
sudo mkfs.fat -F 32 -n EXTRA -s 128 /dev/sdc3
----

<<<

[start=3]
. Confirm that the partition scheme was changed:

[source,shell]
----
lsblk
----

[source]
----
NAME      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
(...)
sda      179:0    0 15,8G  0 disk
├─sda1   179:1    0    1G  0 part
├─sda2   179:2    0    4G  0 part
├─sda3   179:3    0 10,8G  0 part
----

==== +3e

After the microSD card is ready to use you can start the ZX Spectrum core with a +3e ROM and format the IDEDOS part.

The first step is determine the disk geometry. With the microSD card inserted into the ZXTRES enter the command:

[source,basic]
----
CAT TAB
----

This gives a result showing the number of https://en.wikipedia.org/wiki/Cylinder-head-sector[cylinders heads and sectors].

With this information you estimate the size of your partition using cylinders. For example, if the number of cylinders is 32768 and you want to use 1GB of a 16GB microSD card, the number of cylinders needed would be 32768/16=2048. This way the IDEDOS partition can be formatted using that number:

[source,basic]
----
FORMAT TO 0,100,2048
----

The first value (`0`) is the drive to use (the first one). The second value is the maximum number of IDEDOS partitions. The third one is the number of cylinders to use.

After formatting, you can create new partitions. For example, to create a 16MB partition called "Software", a 4GB partition called "Swap" (to use as swap disk) and an 8MB partition called "Utils":

[source,basic]
----
NEW DATA "Software",16
NEW EXP "Swap1",4
NEW DATA "Utils",8
----

For more information about the different +3e disk commands refer to https://worldofspectrum.org/zxplus3e/index.html[this page at World of Spectrum].

<<<

=== esxDOS commands

==== Overview

There are two different kind of esxDOS commands: the so-called "dot" commands that, as the name suggests, begin with a dot (`.`), and extensions to existing BASIC commands.

The main "dot" commands are:

- `128`: Enter 128 mode from within 48 mode.
- `cd`: Change current working folder.
- `chmod`: Change file attributes.
- `cp`: Copy a file.
- `divideo`: Play a divIDEo (`DVO`) video file (divIDE only).
- `drives`: Show currently available drives.
- `dskprobe`: Utility that shows low level content of an storage device.
- `dumpmem`: Can dump RAM memory content to a file.
- `file`: Tries to recognise the type of data contained in a file (like the UNIX command).
- `gramon`: Monitor to search graphics sprites fonts and so on in RAM memory.
- `hexdump`: Shows the contents of a file using hexadecimal notation.
- `hexview`: Allow to see and navigate through the contents os a file using hexadecimal notation.
- `launcher`: Creates a shortcut (launcher) to open directly a `TAP` file.
- `ls`: Show the content of a folder.
- `lstap`: Show the content of a `TAP` file.
- `mkdir`: Create a folder.
- `mktrd`: Create a `TRD` disk file.
- `more`: Show the content of a text file.
- `mv`: Move a file.
- `partinfo`: Show partition information of an storage device.
- `playpt3`: Play `PT3` music file.
- `playsqt`: Play `SQT` music file.
- `playstc`: Play `STC` music file.
- `playtfm`: Play `TFC` music file.
- `playwav`: Play `WAV` audio file.
- `rm`: Remove a file or a folder.
- `snapload`: Load snapshot file.
- `speakcz`: Read text aloud using Czech pronunciation.
- `tapein`: Mounts a `TAP` file so that it can be used then from BASIC using LOAD sentence.
- `tapeout`: Mount a `TAP` file so that it can be used then from BASIC using SAVE sentence.
- `vdisk`: Mount a `TRD` disk file to use with the TR-DOS environment (after all drives have been mounted you can enter TR-DOS emulation by typing: `RANDOMIZE USR 15616`).

Some BASIC extended commands are:

- `GO TO` to change the current drive or folder (for example: `GO TO hd1` or `GO TO hd0"GAMES"`).
- `CAT` to show the content of a drive.
- `LOAD` to lad a file from a drive (BASIC Program SCREEN CODE and so on for example `LOAD *"Screen.scr" SCREEN$`).
- `SAVE` to save data in a file (for example, `SAVE *"PROGRAM.BAS"`).
- `ERASE` to remove a file.

In addition esxDOS supports an NMI browser that loads when the NMI is activated (`F5` is pressed). This enables you to browse the microSD card and easily load files (`TAP`, `Z80`, `TRD` and so on). In the default NMI browser, pressing the `H` key invokes a help screen that shows all available key commands.

[NOTE]
====
The NMI browser shows file and folder entries in the order stored in the internal FAT table and not alphabetically. If you want to see them ordered you must reorder the microSD card structure with a utility such as https://fatsort.sourceforge.io/[FATsort], https://www.luisrios.eti.br/public/en_us/projects/yafs/[YAFS], http://www.trustfm.net/software/utilities/SDSorter.phpp[SDSorter] or another application.
====

[CAUTION]
====
**Don't use any FAT reordering utility** if the microSD card is also being used with a PC XT core because it may stop DOS from booting.
====

<<<

==== ZXTRES Commands

As noted in the installation section, there are a several <<#_esxdos_commands,"dot" command >> commands that are exclusive to the ZXTRES:

- `back16m`: Dumps to a `FLASH.ZX1` file in the root folder of the microSD card the contents of a 16 Meg SPI Flash memory. After the command is done, you must enter `.ls` so that the cache is written to the microSD card. Otherwise the length of the file is wrongly set to 0.
- `backzx2` or `backzxd`: Creates a `FLASH_32.ZX2` or `FLASH_32.ZXD` file in the root folder of the microSD card with the contents of a 32 Meg SPI Flash memory. After the command is done, you must enter `.ls` so that the cache is wrtten to the microSD card. Otherwise the length of the file is wrongly set to 0.
- `core`: Restarts the FPGA and loads the specified core from the SPI Flash
- `corebios`: Simultaneously update the ZX Spectrum core and BIOS.
- `dmaplayw`: Play a `WAV` file that is 8-bits unsigned and sampled at 15625 Hz.
- `esprst`: Reset the WiFi ESP8266(ESP-12) module.
- `iwconfig`: Configure the WiFi module.
- `joyconf`: Configure and test for keyboard and DE9 controllers.
- `keymap`: Load a different keyboard map definition.
- `loadpzx`: Load a `PZX` tape file.
- `loadtap`: Load a `TAP` file using the `PZX` integration.
- `playmid`: Play a `MID` music file using the for <<#_middle_board,middle board>>.
- `playrmov`: Play <<#_creating_radastanian_movie_files,radastanian format video files `RDM`)>>. This command doesn't work in 48K mode.
- `romsupgr`: Load from a RomPack filel called `ROMS.ZX1` in the root folder of the microSD card all ZX Spectrum core ROMS into SPI flash memory.
- `upgr16m`: Load the content of a `FLASH.ZX1` file in the root folder of the microSD card to a 16 Meg SPI Flash memory.
- `upgrzx2` or `upgrzxd`: Write the content of a `FLASH_32.ZX2` or `FLASH_32.ZXD` file in the root folder of the microSD card to a 32 Meg SPI Flash memory.
- `zxuc`: Configure all options of BIOS that also can be stored in the microSD in configuration files that can be loaded later (available to download from https://github.com/Utodev/ZXUC/tree/master/downloads[Utodev repository]).
- `zxunocfg`: Configurae certain features such as timings contention keyboard type CPU speed video type or vertical frequency.

[CAUTION]
====
The `romsback` command is designed for the ZX-Uno and ZX-Dos and must not be used with the ZXTRES.
====

[TIP]
====
Most of these commands are available to download from https://github.com/zxtres/dot_commands[ZXTRES] official repository or https://github.com/zxdos/zxuno/tree/master/SD/BIN[ZX-Uno repository].
====

<<<

=== Wi-Fi

The <<#_middle_board,optional middle board>> includes an ESP-12 Wi-Fi https://es.wikipedia.org/wiki/ESP8266[ESP8266] chip. To communicate with the chip, a core that synthesize a https://en.wikipedia.org/wiki/Universal_Asynchronous_Receiver-Transmitter[UART] device, (such as the EXP28 290723 ZX Spectrum core) is required.

There are two <<#_esxdos_commands,"dot" command >> commands for configuring software access to the module. They can be downloaded from https://github.com/zxdos/zxuno/tree/master/SD/BIN/[GitHub official repository]:

- `esprst` restarts the module.
- `iwconfig` registers the Wi-Fi network name (SSID) and password, keeping them in the file `/sys/config/iw.cfg` for other programs to use.

For example:
[source,shell]
----
.iwconfig mywifi mypassword
----

[TIP]
====
All the Wi-Fi software (explained later) is available with the https://www.retrowiki.es/viewtopic.php?f=110&t=200039549[ZX-Uno distributions by desubikado].
====

==== Network tools for ZX-Uno pack

These ZX Spectrum programs, developed by Nihirash, are available https://nihirash.net/projects/[from his website]:

- `netman`: Configures the ESP Wi-Fi chip for other programs from Nihirash. It doesn't work in 48K mode. Available to download https://github.com/nihirash/netman-zx[from GitHub].
- `Moon Rabbit`: https://es.wikipedia.org/wiki/Gopher[Gopher] client. Doesn't work in 48K mode. Available to download https://github.com/nihirash/moon-rabbit-zx[from GitHub].
- `irc`: https://en.wikipedia.org/wiki/Internet_Relay_Chat[Internet Relay Chat] client. Works better at 14 MHz CPU clock.
- `wget`: Utility to download files with HTTP (does not work with HTTPS)
- `platoUNO`: https://en.wikipedia.org/wiki/Programmed_Logic_Automated_Teaching_Operations[PLATO] client. Also works better at 14 MHz CPU clock. For more information about PLATO, refer to the https://www.irata.online/%23about[IRATA.ONLINE] website.

<<<

==== FTP-Uno

FTP client developed by Yombo, available https://github.com/yomboprime/FTP_Uno[from GitHub].

Configuration steps:

. Edit `FTP.CFG` file with all the required information (SSID and password, FTP server, and so on).
. Copy `FTP.CFG` inside the `/SYS/CONFIG/` folder on the microSD card.
. Copy `ftpUno.tap` to any folder on the card.
. Power on the ZXTRES and load the tape file `ftpUno.tap`

==== UART Terminal

Program example included with https://github.com/yomboprime/ZXYLib[ZXYLib] C library, developed by yombo, that let's you send directly typed characters using the UART, and also see the result. Available to download https://github.com/yomboprime/ZXYLib/raw/master/UARTTERM.tap[from this link].

After the file `UARTTERM.tap` is in the card and loaded, you can type several specific commands for ESP8266 chip. For example:

- `AT`: Check communication. Returns `OK` if everything is working.
- `AT+RST`: Restart the chip, like the <<#_wi_fi,`esprst`>> command.
- `AT+GMR`: Display information such as firmware version and so on.
- `AT+CWMODE_CUR=1`: Temporarily put the chip into Wi-Fi client mode until the next restart.
- `AT+CWMODE_DEF=1`: Put the chip into Wi-Fi client mode, and save it as the default in the chip flash memory.
- `AT+CWJAP_CUR="<WiFiNetwork>","<WiFiPassword>"`: Temporarily connect to a network where `<WiFiNetwork>` is the Wi-Fi ID and `<WiFiPassword>` is the access password.
- `AT+CWJAP_DEF="<WiFiNetwork>","<WiFiPassword>"`: Connect to a network, and saves the settings as default in the chip flash memory.
- `AT+CWAUTOCONN=1`: Set the chip to connect automatically on boot to the default network (`AT+CWAUTOCONN=0` deactivates it).

For full details of all the available commands, refer to the https://www.espressif.com/sites/default/files/documentation/4a-esp8266_at_instruction_set_en.pdf[official documentation].

<<<

=== MIDI

The <<#_middle_board,optional middle board>> also has a built-in https://www.raspberrypi.com/documentation/microcontrollers/raspberry-pi-pico.html%23rp2040-device [RP2040 microcontroller] programmed to work as a GM-MIDI synthesizer. This can be used with a core that enables communication with the module (such as the EXP28 290723 ZX Spectrum core).

You can use the <<#_esxdos_commands,"dot" command >> https://github.com/zxtres/dot_commands/tree/main/playmid[.playmid] to listen to MIDI files in the supported format (**FIXME**).

[NOTE]
====
Sometimes `.playmid` may play a MIDI file slower or with an uneven playback speed. This is because playing this kind of file can involve https://zxuno.com/forum/viewtopic.php?t=3963 [expensive calculations on the Z80] and due to inherent hardware limitations (the ZX Spectrum core's synthesized AY-3-8912 chip that handles serial communiction with the MIDI chip).

To remedy this, change the CPU speed with the `.zxunocfg -sSPEED` command (with SPEED ranging from 0 to 3, where 3 is the fastest) before using `.playmid`, so that you have more CPU power to process the MIDI file.
====

It is also possible to use MIDI with the 128 BASIC `PLAY` command. You can access 128 BASIC from the <<#_derbypro, DerbyPro>> ROM. If you are using a 128K Spectrum ROM, deactivate the microSD card in the BIOS or using the <<#_esxdos_commands,"dot" command >> `.zxuc` command. This command plays a musical scale with the sound of a piano:

[source,basic]
----
PLAY "T160","","","Y1Z192Z0V15O5cdefgabC"
----

[TIP]
====
Changing `0` in `Z0` to another number (from 0 to 127) changes the instrument used to play the scale.
====

The `PLAY` command in <<#_se_basic_iv, SE Basic IV>> also supports MIDI, but it has a different https://github.com/source-solutions/sebasic4/wiki/Language-reference#PLAY[syntax].

==== Bob Fossil NMI Browser

To use https://www.zxuno.com/forum/viewtopic.php?f=39&t=4011 [Bob Fossil's NMI Browser] to play MIDI you need:

- `.playmid` <<#_esxdos_commands,"dot" command >> command installed.
- The latest http://www.thefossilrecord.co.uk/wp-content/uploads/zx/BROWSE_latest.zip[browser stable version].
- Browser MID plugin.

Copy the corresponding `.MID` file to the desired location on the microSD card, together with the appropriate MID plugin file (in the `BIN/BPLUGINS` folder) and the <<#_esxdos_commands,"dot" command >> `playmid` command file (in the `BIN` folder).

. Start the ZXTRES ZX Spectrum core.
. Press `F5` to open Bob Fossil's NMI browser and then navigate to the location of the `.MID` file, select it and press `Enter``.

You can press `Space` to stop playback at any time.

==== ZX MIDI player

This ZX Spectrum program was https://github.com/UzixLS/zx-midiplayer[developed by Eugene Lozovoy] and has the following features:

- Compatible with MID(SMF) file formats type 0, type 1 and RMI;
- Supports files up to 64Kb.
- Support for up to 60 tracks in a file (for heavier files, a turbo CPU frequency is desirable).
- Support for multiple CPU frequencies - 3.5 MHz, 3.54 MHz, 7 MHz, 14 MHz, 28 MHz.
- Support for divMMC (and derivatives), ZXMMC, Z-Controller- FAT32 file system support.

<<<

=== RTC

<<<

=== Creating RaDastanian movie files

The `playrmov` <<#_esxdos_commands,"dot" command >> command plays Radastanian format (`RDM`) video files. To convert your own videos you need `makevideoradas`, a utility that's available at this https://svn.zxuno.com/svn/zxuno/software/modo_radastan/videos_radastanianos/[SVN repository].

If you're using Windows there's already an executable file (`makevideoras.exe`). For Linux or macOS you must have the command line developer utilities installed to compile an executable.

[source,shell]
----
gcc makevideoradas.c -o makevideoradas
----

Apart from `makevdideoradas` you need another two tools: https://ffmpeg.org[`ffmpeg`] and https://imagemagick.org/index.php[`imagemagick`]. These can be installed with a package manager (`apt` `yum` `pacmam` `brew` and so on) or downloading the source code and compiling.

The first step to convert your video (for example `myvideo.mp4`) is exporting the frames as 128x96 pixel BMP image files. You can create a temporary file (`img` for this example) to store them.

[source,shell]
----
mkdir img
(...)/ffmpeg -i myvideo.mp4 -vf "scale=128:96,fps=25" -start_number 0 img/output%05d.bmp
----

Now you can transform the `BMP` files to 16 colours (v3) `BMP` files.

[source,shell]
----
(...)/magick mogrify -colours 16 -format bmp -define bmp:format=bmp3 img/*.bmp
----

Last you can assemble the `RDM` file (in this example `myvideo.rdm`) and cleanup the temporary files and folder.

[source,shell]
----
(...)/makevideoradas img/output
mv img/output.rdm ../myvideo.rdm
rm -rf img
----

For more information about this process refer to https://www.zonadepruebas.com/viewtopic.php?t=4796&start=110[this thread in Zona de Pruebas forums].

<<<

== Upgrade

=== BIOS

To update the BIOS, a file called `FIRMWARE.ZX3` must be obtained. The latest version of the firmware files can be downloaded from https://github.com/zxdos/zxuno/tree/master/firmware[the official repository].

[CAUTION]
====
Updating the firmware (BIOS) is delicate. It shouldn't be done if it's not necessary. When doing so, ensure that the ZXTRES has uninterrupted power (such as a UPS or a laptop USB with battery).
====

Copy the file to the root of the microSD card, power on and press `F2` to enter BIOS. Select `Upgrade`. Choose __"Upgrade BIOS for ZX"__ and then __"SDfile"__. The system reads the file `FIRMWARE...` and notifies you when it's done.

=== ROMs

The flash memory of a ZXTRES has 64 reserved slots of 16K each to store ZX Spectrum core ROM images. Thus an original ZX Spectrum ROM (16K) uses one slot, a ZX Spectrum 128 ROM (32K) uses two slots and a ZX Spectrum +3 ROM (64K) uses four slots.

You can add a new ROM pressing the key `N` at the BIOS <<#_roms,ROMs screen>>, connecting an audio cable to the board and loading a ROM from an audio player. ROM audio tapes can be made from a `TAP` file built with the `GenRom` utility available at the https://github.com/zxdos/zxuno/tree/master/modflash[ZX-Uno Code Repository].

To update all ROMs installed for the ZX Spectrum core in one go, a RomPack file called `ROMS.ZX1` must be obtained that must be copied to the microSD card. Boot the ZXTRES and then enter `.romsupgr`. This overwrites the existing set of ROMs with those contained in the file.

[WARNING]
====
Currently, `romsupgr` only works correctly with RomPack files containing a maximum of 35 slots.
====

RomPack files can be easily edited with the http://guest:zxuno@svn.zxuno.comsvn/zxuno/software/ZX1RomPack/[ZX1RomPack] utility. Although it's a Windows program it works perfectly for example using https://www.winehq.org[Wine] or similar programs either on Linux and macOS versions with 32-bit Intel support..

=== Cores

A core is a file with the information needed to configure the FPGA to behave like a specific system (ZX Spectrum and so on). In the ZXTRES this file can be loaded from several different places: the SPI Flash memory, a microSD card or from an external device (PC and so on) using a special cable.

<<<

==== microSD card

===== Loading from the ZX Spectrum core

From the main ZX Spectrum core it's possible to load other cores. 

====== Bob Fossil NMI browser

To use the https://www.zxuno.com/forum/viewtopic.php?f=39&t=4011[Bob Fossil NMI browser] to load cores you need:

- The latest stable version (http://www.thefossilrecord.co.uk/wp-content/uploads/zx/BROWSE_latest.zip).
- The ZX3 plugin that can load Cores in ZX3 format https://github.com/zxdos/zxuno/blob/master/SD/BIN/BPLUGINS/ZX3.

Copy the corresponding `ZX3` file to the desired location of the microSD card as well as the appropriate ZX3 plugin (in the folder `BIN/BPLUGINS`).

Press `F5` to open Bob Fossil's NMI browser and get to the location of the Core with extension `ZX3`, select it and press `Enter`.

If everything worked correctly, the bottom of the screen indicates the flashing progress (it's recorded in a temporary slot of the flash memory).

====== Bob Fossil NMI browser (with Middle Board)

The <<#_middle_board,optional middle board>> has a built-in https://www.raspberrypi.com/documentation/microcontrollers/raspberry-pi-pico.html%23rp2040-device [RP2040 microcontroller] programmed to read from the microSD and perform direct loading of cores into the FPGA.

In order to use https://www.zxuno.com/forum/viewtopic.php?f=39&t=4011 [Bob Fossil's browser for this type of loading], the following is required:

- The latest http://www.thefossilrecord.co.uk/wp-content/uploads/zx/BROWSE_latest.zip[stable version]
- The BIT plugin to to load Cores in BIT format (https://github.com/zxdos/zxuno/blob/master/SD/BIN/BPLUGINS/BIT).

Copy the corresponding `.BIT` file to the desired location on the microSD card, as well as the BIT plugin file (inside the `BIN\BPLUGINS` folder).

. Start the ZXTRES Spectrum core.
. Press `F5` to open the browser and then navigate to the location of the Core with `.BIT` extension, select it and press ENTER.

If all goes well, after a few seconds, the core will be loaded into the FPGA and then the FPGA will be restarted to execute it.

==== SPI Flash Memory

There are 27 spaces where you can store cores, with the first spaces being reserved for the main ZX Spectrum (this doesn't prevent having more ZX Spectrum cores in other spaces as well of the first ones).

Official cores are https://github.com/zxtres/cores[available to download] from GitHub repository.

To update or install a new core in the SPI Flash there are several possibilities.

The first options is to obtain the latest version of the files that define the core. If the space used is greater than 1179648 bytes it must be split accordingly into several files. Each of these pieces must be a file called `COREXXy.ZX3` where `XX` is _always_ a two digit number. The `y` part of the name is ignored so you can use longer and more descriptive names (for example `CORE04_example_part1.ZX3`).

Copy the files to the root of the microSD card, power on and press `F2` to enter the BIOS. Choose `Upgrade`, select the row corresponding to the chosen core space (for example 4), press enter and then __" SD file "__. The system reads the file `COREnn ..` and notifies you when it's updated. However, first it asks for the name (to be shown in the list to choose from at startup and in the BIOS list). For cores using more than one space, typically the name of the core is only used for the first space and the remaining spaces are registered with some text warning not to use them. After it's installed you can use the core on boot by choosing the first space used by the core.

[WARNING]
====
The main ZX Spectrum core update is exactly the same as other cores but for the first part instead of the name `CORE1.ZXX` it must be a file called `SPECTRUM.ZX3` with a special format.
====

<<<

=== esxDOS

To update esxDOS to a new version the distribution must be obtained from https://www.esxDOS.org[the official website].

After you've downloaded and extracted the `ZIP` archive, the contents of the `BIN` and `SYS` folders must be copied to the root of the microSD card partition merging with the existing ones (to preserve the exclusive ZXTRES commands).

Copy `ESXMMC.BIN` (or `ESXMMC.ROM` depending on version) to the root of the microSD card.

Power on the ZXTRES with the microSD card inserted and press `F2` to access BIOS setup. Select the `Upgrade` menu and choose __"Upgrade esxdos for ZX"__. In the dialog that appears choose __"SD file"__ and when it asks __"Load from SD"__ answer __"Yes"__ to the question __"Are you sure?"__. The content of the file `ESXDOS...` is read and written to the flash storage and you are notified when it's updated.

Do a hard reset or power cycle the ZXTRES.

If everything was done correctly, when you start the ZX Spectrum core you'll see esxDOS detect the microSD card and load the required components to work, showing the new version at the top.

=== Flash Memory

You also can update all FPGA flash memory. At this moment from the BIOS you can only use 16MiB image files. To use a 32MiB image you must use <<#_esxdos,esxdos>> `UPGRZXD` command and a file called `FLASH.ZXD`.

Copy the image file (16MiB) `FLASH.ZX3` to the root of the microSD card.

Power on the ZXTRES and press the `F2` key during boot to access the BIOS setup. Select the menu `Upgrade` and then choos the option __"Upgrade flash from SD"__. Press Enter choose `Yes` and press Enter again to start the Flash writing process.

Do a Hard-Reset or power cycle the ZXTRES.

[WARNING]
====
This process can't be undone and it replaces all previously installed cores, the BIOS, the ZX Spectrum ROMs and their configuration with the data in the image file.
====

<<<

== Other cores

=== Amiga minimig AGA

https://en.wikipedia.org/wiki/Commodore_Amiga [Commodore Amiga] was a personal computer marketed by Commodore International between 1985 and 1994. It was very popular due to its price and multimedia capabilities. Its system is unique in that it was the first multitasking and multimedia computer aimed at the general public.

The ZXTRES core is based on minimig (short for Mini Amiga), which is an open source re-implementation originally authored by Dennis van Weeren. The AGA variant has been updated with AGA chipset capabilities, allowing it to emulate newer Amiga models.

Some core characteristics are:

- Chipset variants : OCS, ECS, AGA
- chipRAM : 0.5MB - 2.0MB, SlowRAM : 0.0MB - 1.5MB and fastRAM : 0.0MB - 24MB
- CPU : 68000, 68010, 68020
- Kickstart support : 1.2 - 3.1
- HRTmon 
- 1-4 floppies with normal and turbo speeds
- 1-2 hard disk images
- VGA video output emulating: PAL / NTSC
- PS/2 mouse support
- Only I^2^S audio

<<<

==== microSD card format

A microSD card, with the first partition in FAT32 format, should be used to store all the necessary files. The `832OSDAD.BIN` file available at https://github.com/zxtres/cores/tree/main/minimig[ZXTRES cores repository] should be copied to the root of the microSD card, together with an Amiga https://es.wikipedia.org/wiki/Kickstart [Kickstart] ROM file, named as `KICK.ROM`.

Optionally, to display an animation at the start of the core, you can also copy to the root the files `minimig.art`,`minimig.bal` and `minimig.cop` which can be obtained from the https://retroramblings.net/?page_id=1422[official Minimig AGA page for Turbo Chameleon 64].

It is also interesting to copy floppy disk image files (`ADF`) and/or https://www.winuae.net[WinUAE] virtual hard disk files (`HDF`) to the microSD.

If not already there, <<#_cores,install or run the Amiga (minimig) core>> on the ZXTRES.

==== Keyboard

===== Special keys and buttons

When the core is active:

- `F12`: show and hide the core control menu.
- `Bloq. Num.`: Turn on or off the use of the numeric keypad as a mouse.

<<<

==== Overview

Press `F12` to display the menu with different core options.

[.text-center]
image:img/minimig.jpg[scaledwidth=70%]

These are the main ones:

- `df0`, `df1`, and so on: To select an `ADF` floppy disk image.
- Floppy Disk Settings: For setting the number of floppy disks and other options.
- Primary Hard Disk: To configure where the primary disk data is located (usually an `HDF` file).
- Secondary Hard Disk `Secondary Hard Disk`: To configure where the data on the secondary disk is located.
- Exit`: Exits the configuration menu.

Using the arrow keys on your keyboard you can access more configuration options:

- `Load Configuration`: To load configuration data saved previously
- `Save Configuration: To save the current configuration. If this is done in the default space (`default`), it is the one that will be used every time the core is started.
- `Chipset Settings`: Here you can choose the CPU, turbo mode, video type (PAL or NTSC), Chipset to simulate.
- `Memory Settings``: To configure the different amounts of RAM memory, as well as the ROM file to be used.
- `Video Settings``: To activate or deactivate video filters, deinterlacing, etc.
- `Reset`: Resets the core to the default settings.
- `Reboot`: Reboot the core with the current settings.

<<<

=== Amstrad CPC 464

The https://en.wikipedia.org/wiki/Amstrad_CPC#CPC_464[Amstrad CPC 464] was the first of a series of 8-bit home computers produced by Amstrad. The ZX-Uno version has been https://www.zxuno.com/forum/viewtopic.php?f=59&t=1346[made by McLeod].

The https://github.com/zxtres/jupiter_ace[ZXTRES core] has been developed by McLeod, starting from the https://zxuno.com/forum/viewtopic.php?f=40&t=75&p=539[original version for ZX-Uno], mainly as a documented example of how to port cores to ZXTRES.

Core features:

- 32KB ROM.
- 64KB RAM.
- AY-3-8912 sound chip.
- Colour module as described in https://worldradiohistory.com/UK/Electronics-Today-UK/80s/Electronics-Today-1984-04.pdf[Electronics Today UK], expanded with programmable border colour.
- DisplaPort video output.
- RGB PAL video output (using the VGA port).
- Support for one controller
- Tape loading using the audio input.
- VGA video output (50 Hz).
- Writable ROM memory (to install alternate ROMs).
- I^2^S and Sigma-Delta audio

==== SD card format

This core does not use the SD card.

If not already there, <<#_cores,install or run the Amstrad CPC core>> on the ZXTRES.

===== Special keys and buttons

When the core is active:

- `Del`: `CLR`.
- `Home` : Scanlines on/off
- `End`: Select one of the monochrome colour modes.
- `Print Scr` or `Left Windows`: `COPY`
- `Scroll Lock`: Switches between RGB (PAL) video mode and VGA (DisplayPort is always active).
- `Ctrl+Alt+Delete`: Soft Reset (resets the Core)
- `Ctrl+Alt+Backspace`: Hard reset (restart the FPGA). Backspace is the delete key located in the top-right portion of the keyboard above `Enter`.

==== Overview

[.text-center]
image:img/cpc464.png[pdfwidth=70%]

When using BASIC, you can load a external tape or other external audio device with the command `RUN"`.
Unlike the original machine, you can hear the audio while playing the tape.

<<<

=== Atari 2600

https://en.wikipedia.org/wiki/Atari_2600[Atari 2600]  is a home video game console originally branded as the Atari Video Computer System (Atari VCS).

ZXTRES core version is developed by avlixa.

Some of the features of the core are:

- DisplaPort video output.
- RGB video output (using the VGA port).
- Support for joysticks, keyboard, mouse.
- VGA video output.
- Only Sigma-Delta audio.

==== microSD card format

You need a microSD card with the first partition in FAT16 or FAT32 format to store ROM image files of the games to load.

If not already there, <<#_cores,install or run the Atari 2600 core>> on the ZXTRES.

==== Keyboard

===== Special keys and buttons

During the core execution:

- `W`, `A`, `S`, `D` or joystick 1: Directional controls for player 1
- `F` or joystick 1 fire button: Player 1 fire button
- `I`, `J`, `K`, `L` or joystick 2: Directional controls for player 2
- `H` or joystick 2 fire button: Player 2 fire button
- `Scroll Lock`: change between RGB and VGA video mode
- F11` or `Ctrl+Alt+Backspace`: Hard reset (restart the FPGA). Backspace is the delete key located in the top-right portion of the keyboard above `Enter`.

<<<

==== Overview

Pressing `Esc` or joystick button 2 shows or hides the configuration menu. Cursor keys and `Enter` to select and choose menu options.

[.text-center]
image:img/a2600.jpg[pdfwidth=70%]

The following options are available:

- Reset core
- Scanlines
- RGB Mode (PAL/NTSC)
- Color
- Difficulty A
- Difficulty B
- Select
- Start
- Load ROM
- Joystick
- Paddle Accuracy
- Exit

<<<

=== ColecoVision

https://en.wikipedia.org/wiki/ColecoVision[ColecoVision] is Coleco Industries' home video-game console that was released in August 1982.

The ZXTRES core is based on https://github.com/fbelavenuto/colecofpga[ZX-Uno version] by Fabio Belavenuto.

Some characteristics of this core are:

- BIOS ROM is loaded from microSD card.
- Supports multicart ROM also loaded from microSD.
- VGA video output.
- Only Sigma-Delta audio.

==== microSD card format

To store ROM image (games) and other files, use a microSD card with the first partition in FAT16 or FAT32 format.

They can be downloaded from https://github.com/fbelavenuto/colecofpga/tree/master/SD_Card[the original project in GitHub].

After copying the files to the microSD card you must add also the file `MULTCART.ROM` that can be downloaded from https://t.me/zxtresfpga.

If not already there, <<#_cores,install or run the Colecovision core>> on the ZXTRES.

==== Keyboard

===== Special keys and buttons

When the core is active:

- 'Esc': Soft reset (restart the core).
- `0` to `9`: Button 0 to 9 for player 1 and player 2.
- Cursor or `Q`, `A`, `E`, `R` or left controller directions: Directional controls for player 1.
- `U`, `J`, `O`, `P` or right controller directions: Directional controls for player 2.
- `Z` or controller button `A`: Main fire button `1` for player 1.
- `M` or controller button `B`: Main fire button `1` for player 2.
- `X` or controller button `A`: Secondary fire button `1` for player 1 and player 2.
- `T`: Button '*'.
- `Y`: Button '#'.

<<<

==== Overview

On startup the BIOS ROM is loaded from the microSD card and then the multicart ROM.

[.text-center]
image:img/coleco.jpg[scaledwidth=70%]

From the multicart menu use the directional controls to choose a ROM and then push button `A` to load. Pressing 'Esc' restarts the core and reloads the ROM selection menu.

<<<

=== Elan Enterprise

The https://es.wikipedia.org/wiki/Enterprise_128[Enterprise] was a home computer developed by the British company Intelligent Software and marketed by Enterprise Computers from 1983.

The ZXTRES version has been developed by https://github.com/Kyp069/ep[Kyp069].

Some characteristics of this core are:

- Implements 1024 KB of RAM.
- Support for loading a virtual disk image (.vhd file). At boot time the EP.VHD file is automatically loaded if found in the root directory of the SD card.
- External joystick is implemented on the DB9 and internal joystick on the cursor keys, with support for two trigger buttons.
- RGB video output (using the VGA port).
- Only Sigma-Delta audio.

==== microSD card format

A microSD card, with the first partition in FAT16 or FAT32 format, should be used to store the ROM file and the virtual disk images you wish to use.

The ROM file should be copied to the root directory of the SD card as `ep.rom`. Furthermore it is also prepared to work with .VHD (disk image) files, such as the one available with https://www.retrowiki.es/viewtopic.php?f=110&t=200039549 [the ZX-Uno distributions from desubikado],

If not already there, <<#_cores,install or run the Elan Enterprise core>> on the ZXTRES.

==== Keyboard

===== Special keys and buttons

When the core is active:

- F12`: Display the core control menu.
- F1`: Show the file browser if the current drive is F:. Once in the file browser, you can change partition by pressing the partition letter (F, G, H, etc).
- C+F9`: Hard reset the core and reattach the virtual disk drive.
- F9` or `Ctrl+Alt+Del`: Soft Reset (resets the Core).
- F11` or `Ctrl+Alt+Backspace`: Hard reset (restart the FPGA). Backspace is the delete key located in the top-right portion of the keyboard above `Enter`.

<<<

==== Overview

When the correct ROM file is present on the microSD card the machine is started.

Press `F12` to display the menu with the different core options.

[.text-center]
image:img/enterprise.png[scaledwidth=70%]

These are the main ones:

- `Available RAM`: Allows you to change the amount of RAM available for the core.
- `CPU Speed`: To increase or decrease the CPU speed.
- `Load ROM`: To load a ROM file.
- `Mount A:`: To mount a `DSK` disk image.
- `Mount SD`: To mount a `VHD` disk image (needs a hard reset by pressing `C+F9` for the system to start using it)

<<<

[.text-center]
image:img/enterprisefile.jpg[scaledwidth=70%]

When a VHD disk image is mounted pressing `F1` or executing the :FILE command (`:` is obtained by pressing +'+), starts a file browser. Pressing another drive letter (G, H, etc) switches to it.

Executable files are `COM``.

It is also possible to load programs without using the browser. Here is an example:

[source]
----
:h:
:cd b
cd bricky
:load bricky.com
----

<<<

=== Jupiter ACE

The https://en.wikipedia.org/wiki/Jupiter_Ace[Jupiter ACE] was a british micro computer produced by Jupiter Cantab in the early 1980s.

The https://github.com/zxtres/jupiter_ace[ZXTRES core] has been developed by McLeod, starting from the https://zxuno.com/forum/viewtopic.php?f=40&t=75&p=539[original version for ZX-Uno], mainly as a documented example of how to port cores to ZXTRES.

Some characteristics of this core are:

- 51K user memory.
- AY-3-8912 sound chip at ZX Spectrum 128K I/O ports.
- Colour module as described in https://worldradiohistory.com/UK/Electronics-Today-UK/80s/Electronics-Today-1984-04.pdf[Electronics Today UK], expanded with programmable border colour.
- DisplaPort video output.
- Readable pattern RAM.
- RGB PAL video output (using the VGA port).
- Tape loading using the audio input.
- VGA video output.
- Writable ROM memory (to install alternate ROMs).
- I^2^S and Sigma-Delta audio.

==== microSD card format

This core does not use the SD card.

If not already there, <<#_cores,install or run the Jupiter ACE core>> on the ZXTRES.

==== Keyboard

===== Special keys and buttons

When the core is active:

- `Home` : Scanlines on/off
- `End`: Select one of the monochrome colour modes.
- `Scroll Lock`: Switches between RGB (PAL) video mode and VGA (DisplayPort is always active).
- `Ctrl+Alt+Delete`: Soft Reset (resets the Core)
- `Ctrl+Alt+Backspace`: Hard reset (restart the FPGA). Backspace is the delete key located in the top-right portion of the keyboard above `Enter`.

==== Overview

From within Forth, you can load from a external tape or other external audio device with the comand `LOAD <nombre>`.

[CAUTION]
====
Jupiter ACE `TAP` files are different from ZX Spectrum files, and, to be used with some players, they have to be previously converted to `TZX` with the `acetap2zx` utility available at https://guest:zxuno@svn.zxuno.com/svn/zxuno/software/jupiter_ace/utils[ZX-Uno repository] (User `guest`, password `zxuno`).
====

Once the tape has finished loading, type the corresponding command to start the program.

[NOTE]
====
Instead of BASIC like other systems, Jupiter ACE uses https://en.wikipedia.org/wiki/Forth[Forth]. To see the commands currently available (including those that will start a program loaded from tape, you have to type `vlist`.
====

[.text-center]
image:img/ace_vlist.png[pdfwidth=70%]

<<<

=== Neo-Geo

https://es.wikipedia.org/wiki/Neo-Geo[Neo-Geo] is the name of a 16-bit cartridge-based system for arcade as well as home video game consoles released in 1990 by the Japanese video game company SNK. The Neo-Geo system was created as both a platform for arcade machines (MVS or Multi Video System) and as a home game console (AES or Advanced Entertainment System).

The ZXTRES version (by somhi) is based on the https://github.com/robinsonb5/NeoGeo_FPGA[DeMiStified version] of the https://github.com/MiSTer-devel/NeoGeo_MiSTer[original version for MiSTer FPGA].

Some core characteristics are:

- Compatible with Sega Mega Drive (Genesis) controllers.
- MVS and AES support.
- RGB video output (using the VGA port).
- Support for ROMS (not encrypted) in https://wiki.terraonion.com/index.php/Neobuilder_Guide[`NEO` format].
- Support for http://unibios.free.fr/download.html[Universe BIOS].
- I^2^S and Sigma-Delta audio.

==== microSD card format

To store the ROM image files, use a microSDcard with the first partition in FAT16 or FAT32 format.

[TIP]
====
To build .neo files from original ROM files, there are multiple tools that can convert from https://github.com/city41/neosdconv [MAME format] or https://gitlab.com/loic.petit/darksoft-to-neosd/ [Darksoft format].
====

After the files have been copied to the microSD card, you need a BIOS (for example http://unibios.free.fr/download.html[Universe BIOS]), with the name `neogeo.rom`, in the root.

If not already there, <<#_cores,install or run the Neo-Geo core>> on the ZXTRES.

<<<

==== Keyboard

===== Special keys and buttons

When the core is active:

- `F12` displays the core control menu.
- Cursor or a controller connected to the left port: Player 1 direction controls.
- `Right Ctrl` or controller 1 button `A`: Player 1 button `A`.
- `Right Alt` or controller 1 button `B`: Player 1 button `B`.
- `Right Win` or controller 1 button `C`: Player 1's button C.
- `Right Shift` or controller 1 button `D`: Player 1's D button.
- `Start`: Start button of player 1.
- `W`, `A`, `S`, `D` or a controller connected to the right port: Player 2 Directional Controls.
- `Left Ctrl` or controller 2 button `A`: Player 2's A button.
- `Left Alt` or controller 2 button  `B`: Player 2's B button.
- `Left Win` or controller 2 button `C`: Player 2's button C.
- `Left Shift` or controller 2 button `D`: Player's D button 2.
- `Caps Lock`: Start button of player 2.

<<<

==== Overview

When the correct files are present on the microSD card and the core is started, a blank screen is displayed. Press `F12` to display the menu with the different core options.

[text-center]
image:img/neogeo.jpg[scaledwidth=70%]

These are the main ones:

- `Load Cart`: To load from the microSD card a .neo file.
- `Load Cart (skip ADPCM)`.
- `Load BIOS`: To load from the microSD card a BIOS file other than `neogeo.rom`.
- `Load Memory Card`.
- `Save Memory Card`.
- `Mount CD`: Currently unavailable.
- `System Type`: MVS or AES
- `CD Speed`: Currently unavailable.
- `CD Region`: Currently unavailable.
- `CD lid`: Currently unavailable.
- `Video Mode`: NTSC or PAL.
- `Scanlines`: To add a scanline effect, if desired.
- `Blend`: To activate, if desired, an image smoothing effect.
- `Swap Joystick`: To swap the controls of player 1 and player 2.
- `Input`: Currently unavailable.
- `[DIP]`: Currently unavailable.
- `Exit`: Closes the menu.

<<<

=== PC XT

The https://en.wikipedia.org/wiki/IBM_Personal_Computer_XT[IBM Personal Computer XT] or PC/XT was the second model in IBM's PC line.

The https://github.com/zxtres/PCXT_DeMiSTify[ZXTRES core] has been implemented by @somhi using the https://github.com/MiSTer-devel/PCXT_MiSTer[PC XT for MiSTer FPGA] core by @spark2k06.

Some core characteristics are:

- 8088 CPU with these speed settings: 4.77 MHz, 7.16 MHz, 9.54 MHz cycle accurate, and PC/AT 286 at 3.5MHz equivalent (max. speed).
- Audio: Adlib, Tandy, Game Blaster, Speaker.
- CGA graphics 32kB VRAM.
- Controller support.
- EMS memory up to 2Mb.
- Main memory 640Kb + 384Kb UMB memory.
- MDA monochrome.
- Mouse support into COM2 serial port, this works like any Microsoft mouse.
- RGB 15 kHz video output (using the VGA port).
- Selectable BIOS (Tandy 1000 / PCXT, IBM5160, Yuko ST, pcxt31, Tandy, micro8088, XT-IDE, ...).
- Support for IBM Tandy 1000.
- Support for IBM PCXT 5160 and clones
- Tandy graphics with 128Kb of shared VRAM.
- VGA video output.
- XT-IDE support.
- I^2^S and Sigma-Delta audio.

<<<

==== microSD Card Format

A microSD card, with the first partition in FAT16 or FAT32 format, should be used to store disk image and BIOS files.

For the BIOS files to load automatically, they must be in the root of the SD card with the following names:

- `PCXT.ROM` for the PCXT BIOS.
- `TANDY.ROM` for the TANDY 1000 BIOS
- `XT-IDE.ROM` for the XT-IDE BIOS (needed to load a system from a `VHD` image).

In addition, it is also prepared to work with DOS file system formatted .VHD (disk image) files, such as the one available at https://github.com/MiSTer-devel/PCXT_MiSTer/raw/main/games/PCXT/hd_image.zip[the core code repository].

If disk image files with the names `PCXT1.VHD` (primary IDE) and `PCXT2.VHD` (secondary IDE) are copied to the card root, they will be loaded automatically at core startup, without having use the configuration menu.

If not already present, <<#_cores,install or run the PC XT core>> on the ZXTRES.

==== Keyboard

===== Special keys and buttons

When the core is active:

- `F12`: Show or hide the core control menu.
- `F12` (long press): Toggle between RGB and VGA mode

<<<

==== Overview

Pressing `F12` will display the menu with the different Core options.

[text-center]
image:img/pcxt_zxtres.png[scaledwidth=70%]

These are the main ones:

- `Model`: To choose between PC XT and Tandy.
- `CPU Speed`: CPU speed. 4.77 MHz offers the best compatibility, 3.5 Mhz the best speed.
- `Mount IDE 1`: To mount a VHD file as primary disk.
- `Mount IDE 2`: To mount a VHD file as a secondary disk.
- `BIOS``: To define the different BIOS types. The XT-IDE BIOS is required to load the OS from VHD disks.
- `Audio`: To indicate the audio emulation to use (Adlib, SB, etc.) as well as the volume.
- `Video`: To modify the different video options.
- `Exit`: Closes the core options menu.

<<<

=== Test DP

The purpose of this core is to test the VGA, RGB and DisplayPort video outputs by applying different effects.

Its main characteristics are:

- 15 kHz RGB video output (using the VGA port).
- DisplaPort video output.
- Monochrome green amber white and colour modes.
- Scanlines.
- VGA video output.

==== microSD card format

This core doesn't use the microSD card.

==== Keyboard

===== Special keys and buttons

When the core is active:

- `1`: Changes the VGA output to RGB 15 kHz.
- `2`: Toggles scanlines on or off.
- `3`: Toggles the display between colour, monochrome, green, amber and white modes.

[NOTE]
====
The previously mentioned effects with keys `2` and `3` are not visible on the original 15 kHz output.
====

<<<

==== Overview

When the core is started, it sends the video signal using both VGA and DisplayPort. The refresh rate is about 64 Hz.

The three LEDs on the ZXTRES board have these meanings:

- The one closest to the edge should be on all the time. This is the DONE LED and it's managed by the FPGA itself not the core.
- The middle one indicates when lit that there's a valid transmission link between the FPGA and the DisplayPort monitor. This means that the link is good that the training was successful and that it's currently sending a video image to the monitor. If it's off it means that the link could not be established (for example because the cable was removed or the monitor is switched off or perhaps because the DisplayPort input is not selected on that monitor).
- The one on the other end should be blinking at a rate of about one blink per second. This is a "pulse" of the pixel clock indicating that both the VGA and DisplayPort outputs are generating an image. If this LED doesn't blink no image of any kind can be seen on either VGA or DisplayPort, only RGB at 15 kHz. Under normal circumstances whether a DisplayPort monitor is plugged in or not this LED should be blinking.

<<<

=== ZX81

The https://en.wikipedia.org/wiki/ZX81[ZX81] was a home computer designed by Sinclair Research to be a low-cost introduction to home computing for the general public.

The ZXTRES version was made by avlixa based on Grant Searle's ZX80 page.

Features:

- 8KB with CHR$128/UDG addon (not tested).
- 16k/32k/48k RAM packs.
- Chroma 81 (colour support).
- Controller types: Cursor, Sinclar, ZX81 and ZXpand.
- Load alternative ROMs.
- PAL/NTSC timings.
- Program loading using the audio input.
- QS CHRS (not tested).
- RGB video output (using the VGA port).
- Turbo in Slow mode: NoWait, x2 and x8.
- Turbo loading of `O` and `P` files.
- YM2149 sound chip (ZON X-81 compatible).
- VGA video output.
- ZX80/ZX81 selectable (ZX80 currently working only in RGB mode).
- Only Sigma-Delta audio.

==== microSD card format

To store ROM and tape files, use a microSDcard with the first partition in FAT16 or FAT32 format.

You can copy a file called `ZX8X.ROM` (available at the https://github.com/avlixa/ZX81_MiSTer_zxdos/raw/master/roms/zx8x.rom[official repository] into folder `/zx81/roms`: it's a concatenation of ZX81 rom (8k) + ZX80 rom (4k).

See the <<#_cores,corresponding section>> for instructions on how to install the ZX81 core in ZXTRES.

<<<

==== Keyboard

The PS/2 keyboard isn't mapped and the original machine keys layout is kept. For example to obtain a `"` you must type `Shift+P` or `Shift+0` to delete.

**ZX80**

[.text-center]
image:img/keyboardZX80.jpg[scaledwidth=80%]

**ZX81**

[.text-center]
image:img/keyboardZX81.jpg[scaledwidth=80%]

===== Special keys and buttons

When the core is active:

- `F1`: Enable or switch off the alternative chararacters.
- `F5` or controller button `B`: Show or hide configuration menu.
- `F9`: Enable or switch off the MIC audio output (some games make annoying sounds when enabled).
- `F10`: Enable or switch off playing the audio input through the audio output to hear loading sounds while loading.
- `Scroll Lock`: Switch between RGB and VGA video output.
- `Ctrl+Alt+Supr`: Soft reset (restart the core).
- Ctrl+Alt+Backspace`: Hard reset (restart the FPGA). Backspace is the delete key located in the top-right portion of the keyboard above `Enter`.

<<<

==== Overview

Press `F5` or controller button `A` to show or hide the configuration menu. Use the cursor keys and `Enter` to select menu options.

[.text-center]
image:img/zx81.jpg[scaledwidth=70%]

The available options are:

- Reset.
- Load Tape.
- Load ROM.
- Configuration Options.
- Exit.

<<<

[.text-center]
image:img/zx81_2.jpg[scaledwidth=70%]

- Computer Model: ZX80, ZX81.
- Main RAM: 16K, 32K.
- Low RAM: Off, 8KB.
- Joystick: Cursor, Sinclair, ZX81.
- QS CHRS: Enabled, Disabled.
- CHR$128/UDG: 128 chars, 64 chars, Disabled.
- Chroma81: Enabled, Disabled.
- Inverse Video: Off, On.
- Black Border: Off, On.
- Slow mode speed: Original, No Wait, x2.
- Video frequency: 50 Hz, 60 Hz.

You can load a tape file selecting it from the menu then enter the command `LOAD""` and `Enter`.

[TIP]
====
Some monitors stop playing audio if the video signal is lost. You should connect headphones or a external speaker if you want to hear the sound while loading a tape.
====

`P` files with colourization and char are supported.

For colourization to work CHROMA81 should be enabled before loading. For alternate chars QS CHRS should be enabled before loading.

[TIP]
====
The recommended options for most games are:

Main RAM: 16KB.
Low RAM: 8KB.
CHR$128: 128 chars.
QS CHRS: Enabled.
CHROMA81: Enabled.
====

<<<

=== ZX Spectrum +3 (zxp3)

https://en.wikipedia.org/wiki/ZX_Spectrum%23ZX_Spectrum_+3

The https://es.wikipedia.org/wiki/ZX_Spectrum_128_%2B3 [ZX Spectrum +3] was manufactured by Amstrad and released in 1987. It was similar in appearance to the +2 but featured a 3-inch floppy disk drive from the tape drive, and had a black casing. It was the only Spectrum capable of running the CP/M operating system without additional hardware.

The ZXTRES version has been made by kyp069.

Features:

- 50 Hz VGA video output
- Turbosound
- Tape loading
- Two floppy drives
- ZXMMC disk image support
- Kempston joystick with two trigger buttons
- Joysticks Interface 2
- RGB PAL video output (using the VGA port)
- Supports any +3 compatible ROM, such as Amstrad standard ROM and Garry Lancaster's +3e ROM

<<<

==== microSD Card Format

A microSD card, with the first partition in FAT16 or FAT32 format, should be used to store the disk image or ROM files to be loaded.

The default ROM file should be copied to the root directory of the SD card as `zxp3.rom`. In addition, it is also prepared to work with a VHD (disk image) file formatted internally in the +3DOS file system, such as the one available with https://www.retrowiki.es/viewtopic.php?f=110&t=200039549 [the ZX-Uno distributions from desubikado],

If not already there, <<#_cores,install or run the zxp3 core>> on the ZXTRES.

==== Keyboard

The keyboard is not mapped to the standard PS/2 layout, and keeps the layout of the original machine. So, for example, to get `"` you have to press `Shift+P` or to delete, `Shift+0`.

===== Special keys and buttons

During core execution:

- `F12` to show or hide the menu.
- `Scroll Lock` or presssing and holding `F12` for one second: switch between RGB and VGA video mode.
- Ctrl+Alt+Del` or `F9`: Soft Reset (resets the Core)
- Ctrl+Alt+Backspace` or `F8`: Hard reset (restart the FPGA). Backspace is the delete key located in the top-right portion of the keyboard above `Enter`.

<<<

==== Overview

Press `F12` to display the menu with the different core options.

[.text-center]
image:img/zxp3.jpg[scaledwidth=70%]

- `Load ROM`: To load or change the loaded ROM
- `Mount drive A:`: To mount a DSK file to the first drive
- `Mount drive B:`: To mount a DSK file to the second drive
- `Mount SD:`: To mount a VHD file as main drive (needs a hard reset by pressing `C+F9` for the system to start using it)
- `Reset FPGA`: To reset the FPGA

Controller 1 behaves simultaneously with Kempston protocol (with two trigger buttons) and Sinclair (1,2,3,4,5) with second trigger button (`z`). The controller connected to port 2 behaves with Sinclair protocol (6,7,8,9,0) and second trigger button (`x`).

<<<

=== ZX Spectrum Next

https://www.specnext.com[ZX Spectrum Next] is an FPGA based project, which would like to be to be the evolution of the Sinclair ZX Spectrum line of computers. It brings new features while keeping hardware and software compatibility with previous ZX Spectrum computers.

Specially thanks to avlixa, there exists a ZX Spectrum Next core synthesized for ZXTRES.

The core, for the moment does not have any of these features:

- Internal beeper
- EDGE expansion Connector
- RTC module
- Membrane keyboard
- Flashing additional cores or upgrading the Next core from within the Next core
- MIC out
- HDMI Video
- UART communication using the joystick port
- Raspberry Pi support

It also has these other features, which do not exist in the original core:

- Different colour modes including monochrome
- Only I^2^S audio

The user manual is available to download at https://www.specnext.com/zx-spectrum-next-user-manual-first-edition/[the official web page].

<<<

==== microSD card format

You have to use a microSD card with the first partition formatted as FAT16 or FAT32, and inside, the standard esxDOS distribution, matching ZXTRES BIOS version (see <<#_esxdos,esxdos corresponding section>> for more info).

Download NextZXOS distribution https://www.specnext.com/latestdistro/[from the official page].

Extract NextZXOS in the root of the microSD card.

If not already there, <<#_cores,install or run the ZX Spectrum Next core>> on the ZXTRES.

==== Keyboard

===== Special keys and buttons

While the core is running:

- `F4` (`Caps Shift+Symbol Shift+4` on gomaDOS+): Soft Reset
- `F7` (`Caps Shift+Symbol Shift+7` on gomaDOS+): Select one of the monochrome color modes
- `F9` (`Caps Shift+Symbol Shift+9` on gomaDOS+): NMI
- Ctrl+Alt+Backspace`: Hard reset (restart the FPGA). Backspace is the delete key located in the top-right portion of the keyboard above `Enter`.

<<<

==== Overview

On first boot, some help screens will show up. After pressing `Space` key, NextZXOS Startup Menu appears.

[.text-center]
image:img/next_zxtres.png[pdfwidth=70%]

You can navigate the menu with the cursor keys, `5`, `6`, `7` and `8` keys, or a joystick (if configured as Kempston, MD or cursor). `Enter` or the joystick button chooses one element.

[TIP]
====
During the core startup, you can force select the analogue video output use by pressing `R` for RGB and `V` for VGA.
====

`More...` shows a second menu with more options.

[.text-center]
image:img/next2_zxtres.png[pdfwidth=70%]

<<<

If you choose `Browser`, NextZXOS Browser will start, and then you can see the contents of the microSD card and load a file (TAP, NEX, DSK, SNA, SNX, Z80, Z8, etc.).

[.text-center]
image:img/next3_zxtres.png[pdfwidth=70%]

[NOTE]
====
It is not possible to load TRD files directly from the Browser (NextZXOS must be configured to load a "personality" with esxdos).
====

For more information, see the https://www.specnext.com/zx-spectrum-next-user-manual-first-edition/[official user manual].

<<<

== Other hardware

=== Middle Board

An intermediate board can be installed in a ZXTRES as an optional component that expands the hardware capabilities to include support for:

- <<#_wi_fi,Wi-Fi>> (via https://es.wikipedia.org/wiki/ESP8266[ESP8266])
- <<#_midi,MIDI>> (via https://www.raspberrypi.com/documentation/microcontrollers/raspberry-pi-pico.html%23rp2040-device[RP2040 microcontroller]), 
- <<#_rtc,RTC (real time clock)>>
- <<#_bob_fossil_nmi_browser,direct loading of cores>> from microSD card (via https://www.raspberrypi.com/documentation/microcontrollers/raspberry-pi-pico.html%23rp2040-device[microcontroller RP2040])
- USB keyboards and controllers (via https://www.raspberrypi.com/documentation/microcontrollers/raspberry-pi-pico.html%23rp2040-device[RP2040 microcontroller])

[.text-center]
image:img/middleboardtop.jpg[scaledwidth=40%] image:img/middleboardbottom.jpg[scaledwidth=40%]

==== Recovery via USB

In some situations it may be necessary to reinstall the bootstrap firmware for some https://www.raspberrypi.com/documentation/microcontrollers/raspberry-pi-pico.html%23rp2040-device [RP2040 microcontroller] on the board.

*Hardware required*:

- Computer with USB and compatible with Raspberry Pi Pico.
- Cable with one  USB-A end (to connect to the ZXTRES) and the other end suitable for connecting to the computer (USB-C, USB-A, etc.)

*Software required*:

- Obtain the appropriate UF2 file for the microcontroller to be recovered:

** `rp2s.uf2` for boards with a single microcontroller.
** `rp2m-bootstrap.uf2` for rp2040 MIDI (boards with two microcontrollers)
** `rp2u-bootstrap.uf2` for rp2040 USB (boards with two microcontrollers)

*Steps to follow*:

. Turn off the ZXTRES if it is on, and connect with the USB cable to the computer.
. In the case of boards with two microcontrollers, set the switch to the appropriate position for the rp2040 to be recovered, being position 1 for USB and position 2 for MIDI.

[.text-center]
image:img/bootselsw.jpg[scaledwidth=60%]

[start=3]
. Turn on the ZXTRES while pressing the <<#_ports_and_connectors,BOOTSEL>> button on the bottom of the case.
. Copy the corresponding UF2 file to the drive that will be available on the computer.
. Finally, in the case of boards with two microcontrollers, if necessary, return the switch to position 1 (USB).

<<<

=== Loading from tape

Some cores can load from an external device such as a cassette tape player, just like the original machines.

Besides the microSD card you must connect an appropriate audio cable into the <<#_ports_and_connectors,ZXTRES audio input>>. It must have a 3.5mm stero jack on one side and two mono outputs on the other side (one for each audio channel). The right audio is connected to the audio player (this is not necessary with a miniduino because it already uses only the right audio channel when playing).

==== Cassette tape player

This works exactly the same way as when using it with the original computers:

. Connect the audio cable.
. Type on the computer or select the tape loading option. For examle, for ZX Spectrum 48K press `J` (`LOAD`),  `""` and `Enter` to start loading.
. Start playing the tape (you may need to try several times, adjusting the player volume).

==== Computer

Depending on the operating system (Windows, macOS or Linux) there are several programs that can either play a tape file (`TAP` `TZX` `PZX` and so on) and output the sound through a headphone output or create an audio file (`WAV` `VOC` `AU` and so on) that can be played using a music or audio program.

===== PlayTZX

This program for Windows, macOS and Linux can directly play a `TZX` tape file through the computer's audio output.

You can download the application for Windows from https://worldofspectrum.net/utilities/%23tzxtools[World of Spectrum Classic] and for Mac from https://github.com/kounch/playtzx/releases[this GitHub repository] or compile the source code as <<#_compile_source_code_macos_and_linux,explained later>>.

. Connect the audio cable between the computer audio output and ZXTRES audio input (remember to use only the right mono channel to the PC Mac and so on output). 
. Type on the computer or select the tape loading option. For examle for ZX Spectrum 48K typing `J` then twice `"` and then `Enter` to do the classic `LOAD "" + Enter`.
. Start playing a tape file with this command (you may need to try several times adjusting the player volume).

[source,shell]
----
./playtzx <tape file path>
----

If everything worked correctly, you'll see at the shell the name of the different tape data blocks while the sound is played and the ZXTRES core loads the program.

[TIP]
====
On Linux the program uses as output the device `/dev/dsp` this may require you to load a module like `snd_pcm_oss` (on systems using ALSA).
====

====== Compile source code (macOS and Linux)

Beofre compiling, ensure that the developer tools are installed on the system including a C compiler (`gcc` `clang` command line developer tools for Mac and so on) and https://es.wikipedia.org/wiki/GNU_build_system[GNU Autotools].

Download the source code https://github.com/kounch/playtzx[from this repository]), extract the contents if required, in the terminal navigate to the folder and enter:

[source,shell]
----
aclocal && autoconf && autoheader && automake --add-missing
./configure
make
----

If everything worked correctly, a new file called `playtzx` is created that you can copy anywhere and then use. You can remove the compilation folder.

==== Mobile phone tablet MP3 player and so on

There are only a few apps (or none) that can directly play a tape file on a mobile device so in many cases the only option is to convert it to an audio file before playing it.

https://play.google.com/store/apps/details?id=com.baltazarstudios.playzxtapes[PlayZX] is an app for Android that can play tape files through the headphone output.

[WARNING]
====
The latest devices with headphone output are typically designed to work with impedances of only a few ohmis. This may sometimes not be enouth for the ZXTRES audio input.

In these cases you should (if possible) to switch off headphone volume limitations or use a headphone amplifier that can give a higher impedance.
====

===== Audio file conversion

These are some programas that exist which can export tape files to audio files.

https://www.alessandrogrussu.it/tapir/index.html[Tapir] is a GUI program for Windows (but that can also run with Wine on Linux or versions of macOS with 32-bit Intel support) that can load `TZX` and `TAP` files and export to `WAV` audio

`tape2wav` from https://fuse-emulator.sourceforge.net/[Fuse Utilities] is a command line utility that can export from `TZX` `PZX` and `TAP` to `WAV`.

`pzx2wav` in http://zxds.raxoft.cz/pzx.html[PZX Tools] is another command line utility that exports to `WAV`.

<<<

==== Miniduino

include::miniduino_en.adoc[leveloffset=+3]

<<<

== Troubleshooting

=== Firmware image management

There are several tools that you can use to create or edit the contents of `ZX1` and `ZX3` files.

==== zx123_tool

This tool enables you to analyse, extract and inject data in SPI flash image files for ZX-Uno, ZXDOS, ZXTRES and similar devices.

It requires https://www.python.org/[Python 3]. Depending on the operating system you may need to https://www.python.org/downloads/[install it].

With Python 3 installed, you only need to download the latest version of the tool from the official repository following https://github.com/kounch/zx123_tool/releases/latest[this link].

After you've extracted the tool, you can run it from the command line. The command varies depending on the operating system.

Typically, on Windows it's:

[source,shell]
----
py -3 zx123_tool.py
----

Otherwise, it's typically:

[source,shell]
----
python3 ./zx123_tool.py
----

You also need an SPI flash image file. This can be obtained from within the ZX Spectrum core with one of the commands `back16m` `backzx2` or `backzxd`. After you've obtained the exteacted file from the microSD card you can "clean" it leaving only the ZX Spectrum core and the first Spectrum ROM:

[source,shell]
----
... zx123_tool.py -i FLASH.ZXD -w -o FLASHempty.ZXD
----

Where `FLASH.ZXD` is the path to the original file and `FLASHempty.ZXD` is the path to the new "clean" file.

*List the contents of an image*

To view the contents of an image file called `FLASH.ZXD` (installed cores and some configuration information):

[source,shell]
----
... zx123_tool.py -i FLASH.ZXD -l
----

<<<

To show the contents of the same file including ZX Spectrun ROMs information:

[source,shell]
----
... zx123_tool.py -i FLASH.ZXD -l -r
----

*Change the BIOS of an image*

To change the BIOS inside a file called `FLASH.ZXD` using the BIOS file called `FIRMWARE.ZXD`:

[source,shell]
----
...zx123_tool.py -i FLASH.ZXD -a BIOS,FIRMWARE.ZXD
----

You can modify some parameters. For example with the options; `-m` for video mode: 0 (PAL), 1 (NTSC), or 2 (VGA), `-k` for the keyboard layout: 0 (Auto), 1 (ES), 2 (EN) or 3 (Spectrum).

To change the BIOS of a file called `FLASH.ZXD` using the BIOS file `FIRMWARE.ZXD` and also set the video mode to VGA:

[source,shell]
----
...zx123_tool.py -i FLASH.ZXD -a BIOS,FIRMWARE.ZXD -m 2 -k 3
----

There are also options to set the BIOS boot delay time, the default core and the default Spectrum ROM. For more information, refer to the https://github.com/kounch/zx123_tool/[documentation].

*Add a Spectrum ROM to an image*

To add a Spectrum ROM file called `48.ROM` with the name `Spec48` and using the slot number five:

[source,shell]
----
...zx123_tool.py -i FLASH.ZXD -a ROM,5,xdnlh17,Spec48,48.rom
----

Refer to the https://github.com/kounch/zx123_tool/[documentation] for all possible options when adding a Spectrum ROM.

<<<

Among the information you provide when adding a ROM there are some flags. These configure the hardware options used when loading the ROM:

[align="center",width="70%",%header,cols=2*]
|===
|`i`
|Keyboard issue 3 enabled (instead of issue 2).
|`c`
|Switch off memory contention.
|`d`
|Enable divMMC.
|`n`
|Enable NMI divMMC (esxDOS NMI browser).
|`p`
|Use Pentagon timings.
|`t`
|Use 128K timings.
|`s`
|Switch off divMMC and ZXMMC ports.
|`m`
|Enable Timex Horizontal MMU.
|`h`
|Switch off ROM high bit (1FFD bit 2).
|`l`
|Switch off ROM low bit (7FFD bit 4).
|`1`
|Switch off 1FFD port (+2A/3 paging).
|`7`
|Switch off 7FFD port (128K paging).
|`2`
|Switch off TurboSound (secondary AY chip).
|`a`
|Switch off AY chip.
|`r`
|Switch off Radastanian mode.
|`x`
|Switch off Timex mode.
|`u`
|Switch off ULAplus.
|===

*Install a core to an image*

To install a core in slot three from a file called `SPECNEXT.ZXD` with the name `SpecNext`:

[source,shell]
----
...zx123_tool.py -i FLASH.ZXD -a 'CORE,3,SpecNext,SPECNEXT.ZXD'
----

To also set the core as the default:

[source,shell]
----
...zx123_tool.py -i FLASH.ZXD -a 'CORE,3,SpecNext,SPECNEXT.ZXD' -c 3
----

<<<

*Change esxDOS ROM from an image*

As with the BIOS firmware you can install an esxDOS ROM file:

[source,shell]
----
...zx123_tool.py -i FLASH.ZXD -a esxdos,ESXMMC.BIN
----

*Combine several actions in one line*

You can combine several actions in one command line. For example to "clean" an image file called `FLASH.ZXD` creating a new one called `FLASHnew.ZXD` installing the BIOS from the file `FIRMWARE.ZXD` set up video mode to VGA the keyboard in Spectrum mode add a Spectrum ROM file called `48.rom` with the name `Spec48` while using slot five install a core at slot three from a file called `SPECNEXT.ZXD` with the name `SpecNext` as default core:

[source,shell]
----
... zx123_tool.py -i FLASH.ZXD -w -o FLASHnew.ZXD -a BIOS,FIRMWARE.ZXD -m 2 -k 3 -a ROM,5,xdnlh17,Spec48,48.rom -a CORE,3,SpecNext,SPECNEXT.ZXD -c 3
----

<<<

=== Firmware recovery

Sometimes it may happen that the ZXTRES stops booting, for example when installing an experimental core or when upgrading the ZX Spectrum Core or the BIOS. The ZXTRES board LEDs are on but there's no display and it doesn't do anything when trying the different key combinations to access BIOS setup and so on.

When this happens there are several recovery methods to enable you to restore the firmware.

==== JTAG cable connections

You can use these images as a reference in some recovery steps when using jump wires or USB-Blaster connections to the ZXTRES board.

[.text-center]
image:img/jtagzxtres.jpg[scaledwidth=80%]

[WARNING]
====
*Don't* connect the 3V line.
====

==== Recovery using a Raspberry Pi

*Hardware required*:

- Raspberry Pi (with microSD card, keyboard, display, power supply and so on) and with internet connection.
- Five https://en.wikipedia.org/wiki/Jump_wire[jump wires] (if possible female on both sides) or instead a USB-Blaster cable.
- A hex key (Allen key) for the ZXTRES cover screws.
- A microSD card with the first partition formatted as FAT16 or FAT32 for the ZXTRES.
- Keyboard and display for the ZXTRES.

*Software required*:

Flash image and recovery file for ZXTRES from https://github.com/zxtres/cores/tree/main/recovery[the main Github repository]. Note, there are different files for each device:

** `recovery_a35.bit` for ZXTRES
** `recovery_a100.bit` for ZXTRES+
** `recovery_a200.bit` for ZXTRES++

*Instruction steps*:

. Install Raspberry Pi OS (formerly known as Raspbian) to the Raspberry Pi microSD card (using https://www.raspberrypi.org/downloads/raspberry-pi-os/[the official download] https://www.raspberrypi.org/downloads/noobs/[NOOBS] https://github.com/procount/pinn[PINN] and so on).
. Install Open OCD:

[source,shell]
----
sudo apt-get update
sudo apt-get install git autoconf libtool make pkg-config
sudo apt-get install libusb-1.0-0 libusb-1.0-0-dev telnet
sudo apt-get install libusb-dev libftdi-dev
git clone git://git.code.sf.net/p/openocd/code openocd-code
cd openocd-code/
./bootstrap
./configure --enable-usb_blaster --enable-sysfsgpio --enable-bcm2835gpio
make
sudo make install
cd ..
rm -rf ./openocd-code
----

[start=3]
. Connect the USB-Blaster or jump wires if using GPIO. In this case open the ZXTRES case and <<#_jtag_cable_connections,as explained before>> connect the FPGA JTAG lines (`TMS` `TDI` `TDO` `TCK` and `GND`) using the wires to the Raspberry Pi https://es.wikipedia.org/wiki/GPIO[GPIO] pins.

If using a GPIO connection, take note of the chosen pins and ensure that `GND` is connected with `GND`.

[.text-center]
image:img/gpio.jpg[scaledwidth=70%]

In this example the `31` `33` `35` `37` and `39` pins are used (corresponding to `GPIO #6` `GPIO #13` `GPIO #19` `GPIO #26` and `GND`):

[%header,cols=3*]
|===
|ZXTRES JTAG
|GPIO
|Raspberry Pi Pin
|`TMS`
|GPIO#6
|`31`
|`TDI`
|GPIO#13
|`33`
|`TDO`
|GPIO#19
|`35`
|`TCK`
|GPIO#26
|`37`
|`GND`
|GND
|`39`
|===

[start=4]
. Copy the file called `recovery_axx.bit` previously downloaded from https://github.com/zxtres/cores/tree/main/recovery[the main Github repository] to the Raspberry Pi. In this example it's at `/home/pi/zxtres/unbrick/`

. If using GPIO, make a copy of the Open OCD configuration file to the folder where `recovery.bit` is located.

[source,shell]
----
cp /usr/local/share/openocd/scripts/interface/raspberrypi2-native.cfg /home/pi/zxtres/unbrick/
----

<<<

[start=6]
. For GPIO connection edit a copy of `raspberrypi2-native.cfg`, updating `bcm2835gpio_jtag_nums` (uncommenting if necessary) with your JTAG and GPIO connection numbers at the line `bcm2835gpio_jtag_nums`:

[source]
----
# Header pin numbers: 37 31 33 35
bcm2835gpio_jtag_nums 26 6 13 19
----

[start=7]
. Ensure the line `bcm2835gpio_swd_nums` is commented out (not necessary for USB-Blaster):

[source]
----
#bcm2835gpio_swd_nums 11 25
----

[start=8]
. Add `adapter speed 250` to the end of the file the line (not necessary for USB-Blaster):

[source]
----
adapter speed 250
----

[start=9]
. Power on the ZXTRES.

. Ensure that on the Raspberry Pi you're in the folder where `recovery_axx.bit` is located and run the command that loads the BIOS on recovery mode using the path to the previously edited `raspberrypi2-native.cfg`.

For GPIO connection:

[source,shell]
----
cd /home/pi/zxtres/unbrick
sudo openocd -f /home/pi/zxtres/unbrick/raspberrypi2-native.cfg -f /home/pi/zxtres/unbrick/xilinx-xc7.cfg -c "init; pld load 0 recovery_axx.bit; shutdown"
----

For USB-Blaster connection:

[source,shell]
----
cd /home/pi/zxtres/unbrick
sudo openocd -f /usr/local/share/openocd/scripts/interface/altera-usb-blaster.cfg -f /home/pi/zxtres/unbrick/xilinx-xc7.cfg -c "init; pld load 0 recovery_axx.bit; shutdown"
----

[TIP]
====
Remember to enter the correct name replacing `recovery_axx.bit` in the previous commands.
====

<<<

[start=11]
. If everything worked correctly, you'll see that the FPGA LED change their state and the BIOS is shown on the display.

If there's no image on the display and you're not using DisplaPort, press `Scroll Lock` to switch between RGB and VGA modes in case the recovery BIOS started in the wrong mode for your setup.

[.text-center]
image:img/recovery.png[scaledwidth=70%]

[start=12]
. Insert the microSD card formatted as FAT16 o FAT32 and with the `FLASH.ZX3` file downloaded previously in the ZXTRES.

. If using a USB-Blaster connection, disconnect the connector.

<<<

[start=14]
. Select the `Upgrade Flash from SD` opiton. Press `Enter`, choose `Yes` and press `Enter` again to start the flash writing process.

[.text-center]
image:img/recovery2.png[scaledwidth=70%]

[WARNING]
====
This process can't be undone and replaces all previously installed cores, the BIOS, the ZX Spectrum ROMs and their configuration with the data in the image file.
====

[start=15]
. After some minutes the process ends and on power cycling the ZXTRES it should start.

[NOTE]
====
If no image is shown and you're not using DisplaPort, press `Scroll Lock` again to switch between RGB and VGA modes. In this case you must enter the BIOS and change <<#_advanced,the right advanced setting>> that matches your display.
====

<<<

== References

=== Spectrum

==== Scan Codes

[.text-center]
image:img/ScanCodes.png[scaledwidth=75%]

<<<

==== ZXTRES control I/O registers

In the Spectrum core the `$FC3B` and `$FD3B` ports are reserved and assigned by the https://sinclair.wiki.zxnet.co.uk/wiki/ZXI_standard[ZXI committee]. A total of 256 different I/O registers unique to the ZX-Uno family are accessed through these ports.

Port `$FC3B` (`64571`) stores the address (`$00` - `$FF`) of the I/O register to be accessed. It can be read to find out which register address was last allocated.

Port `$FD3B` (`64827`) is the access port to the register selected with the previous port. Its meaning (read/write) depends on the implementation of each register.

For example, to allocate bank 16 of the SRAM to the address space `$C000` - `$FFFFFF` during boot mode, using the MASTERMAPPER register, would be as follows:

[source,asm]
----
ld bc,$fc3b     ;Port to set register number to use
ld a,1          ;Register $01 (MASTERMAPPER)
out (c),a       ;Selected. From now on, any access to $FD3B is using MASTERMAPPER
inc b           ;Register access port ($FD3B, just increment B)
ld a,16         ;SRAM Bank 16
out (c),a       ;Write to the MASTERMAPPER register
----

The registers implemented in the ZX-Uno family are described below.

<<<

===== `$00` MASTERCONF

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|`00000001`|`00000001`
|===

Binary format (fields in *bold* can only be altered when LOCK=0):
|===
|[.small]#*LOCK*#|[.small]#MODE1#|[.small]#DISCONT#|[.small]#MODE0#|[.small]#I2KB#|[.small]#*DISNMI*#|[.small]#*DIVEN*#|[.small]#*BOOTM*#
|===
* `BOOTM`: 1 indicates that the ZX-Uno is in boot mode (configuration mode). Boot mode only makes sense while the boot firmware is running, where some aspects of the ZX-Uno are allowed to be configured before going into run mode. MASTERCONF can always be read, both in boot mode and in run mode. It is set to 0 manually per program, at which point ZX-Uno enters run mode.
* `DIVEN`: set to 0 indicates that DIVMMC is not enabled in the system, although the SPI interface access ports of the SD/MMC slot are still available. The memory used by DIVMMC remains available for other uses. 1 indicates that DIVMMC is enabled. If enabled, an ESXDOS image must be loaded into the corresponding RAM bank before entering run mode. The default value of this bit is 0.
* `DISNMI`: set to 1 indicates that the DIVMMC NMI function will not be available. NMI will work, but will not cause ESXDOS to automate, thus leaving NMI control to the main system ROM. Bit added to improve DIVMMC compatibility with SE Basic IV. Defaults to 0 (ESXDOS handles NMI events).
* `I2KB``: a1 sets the ULA to return a value consistent with a Spectrum issue 2 when reading the keyboard port ($FE). When 0, the returned value is compatible with issue 3 and later. It defaults to 0.
* `MODE1`,`MODE0`: specifies the ULA timing mode to accommodate different Spectrum models. 00 = ULA ZX Spectrum 48K PAL, 01 = ZX Spectrum 128K/+2 grey, 10 = Pentagon 128, 11 = 48K NTSC (262 scans).
* `DISCONT`: indicates whether memory contention should occur in the video memory. 0 to enable contention (48K and 128K compatibility). 1 to disable contention (Pentagon 128 compatibility).
* `LOCK`: When set to 1, it prevents further changes to certain bits in the MASTERCONF register, and also prevents access to the SPI Flash. This bit is reset to 0 only by a master reset (Ctrl-Alt-BkSpace) or by powering the clone off and on.

<<<

===== `$01` MASTERMAPPER

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|`00000000`|`00000000`
|===

Only the lower 5 bits (values $00 to $1F) of this register are used. The value stored is the number of a 16KB bank of SRAM that will be paged at addresses $C000-$FFFFFF during boot mode. The values in this register have no effect when the ZX-Uno is in run mode. 32 different values for this register allow addressing up to 512KB of SRAM. If ZX-Uno is expanded with more memory, more bits in this register will be used. The maximum manageable amount of memory is 4MB.

===== `$02` FLASHSPI

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|Does not change|`00000000`
|===

Puerto de acceso al registro SPI conectado a la SPI Flash. Escribiendo un valor en este registro, se envía a la SPI Flash, si ésta está seleccionada. Leyendo un valor de este registro, se lee el último valor enviado por la SPI Flash, y además, la misma operación de lectura provoca que la SPI envíe un nuevo valor (que sería leído con la siguiente operación de lectura a este registro). Por esta razón, en operaciones de lectura de bloques, el primer byte leído con este puerto debe descartarse.

===== `$03` FLASHCS

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|Does not change|`00000001`
|===

Only bit 0 is used. The value written to this register determines the status of the CS line of the SPI Flash (0 = Flash selected, 1 = Flash not selected).

===== `$04` SCANCODE

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|Does not change|Does not change
|===

When reading, it allows to obtain the value of the last scancode generated by the keyboard. When writing, it allows to send commands to the keyboard.

<<<

===== `$05` KEYSTAT

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read|Does not change|Does not change|Does not change
|===

Several bits showing whether or not there is a new key pressed, or released, and whether this is an extended or normal key.
|===
|BSY|0|0|0|ERR|RLS|EXT|PEN
|===

* BSY: Uses 1 when a data transmission to the PS/2 port is still in progress. Wait for a value of 0 to start a new transmission.
* ERR: 1 when the last transmission to or from the PS/2 port had errors.
* RLS: 1 when the last event belongs to a key that has been released.
* EXT: 1 when the last event belongs to a key with extended code (E0+scancode).
* PEN: 1 when there is new data ready to be read in the SCANCODE register. After reading KEYSTAT, this bit is set to 0.

===== `$06` JOYCONF

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|Does not change|`00100001`
|===

Bits 0 to 2 show the operating mode of the keyboard mapped joystick (or of the second physical joystick if there is a splitter). Bits 4 to 6 for the operating mode of the physical joystick (DB-9 connector on the side). Bit 3 means autofire of the second joystick or keypad. Bit 7 means autofire of the main joystick. The values are: 000 = Disabled, 001 = Kempston, 010 = Sinclair 1, 011 = Sinclair 2, 100 = Protek/Cursor/AGF, 101 = Fuller, 110 = OPQAspM, 111 = reserved.

===== `$07` KEYMAP

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Read later|Read later|Read later
|===

On read, each access provides the next byte of the currently loaded ZX-Uno keymap. On write, the byte corresponding to the keymap marked by the current position is modified. In both cases, the address pointer is automatically incremented to point to the next byte of the keymap. This pointer returns to 0 automatically after a reset, a write to the $FC3B register, or when the keymap is terminated. The keymap, in the current implementation, occupies 16384 bytes.

<<<

===== `$09` MOUSEDATA

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|Does not change|Does not change
|===

Mouse PS/2 port data register. Used to read or send direct commands to the PS/2 mouse. For example: to initialise the mouse, the value $F4 must be sent to this register.

===== `$0A` MOUSESTATUS

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|Does not change|Does not change
|===

PS/2 mouse port status register. The following bits are set:
|==
|BSY|0|0|0|ERR|0|0|PEN
|==
* BSY: set to 1 when a data transmission to the PS/2 port is still in progress. Wait for a value of 0 to start a new transmission.
* ERR: set to 1 when the last transmission to or from the PS/2 port had errors.
* PEN: set to 1 when new data is ready to be read from the MOUSEDATA register. After reading MOUSESTATUS, this bit is set to 0.

<<<

===== `$0B` SCANDBLCTRL

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|Does not change|`00000000`
|===

Scandoubler control register and system speed. The following bits are defined:
|===
|TURBO|COPT|FREQ|FREQ|ENSCAN|VGA
|===
* TURBO: 00 to select 3.5 MHz, 01 to select 7 MHz, 10 to select 14 MHz and 11 to select 28 MHz. These bits are also updated with the value of bits D0-D3 of port $8E3B, used in the ZX Prism to select the different speeds for the CPU.
* COPT: selects the way to generate the composite syncs for RGB and composite video: 0 to use the original Spectrum sync type. 1 to use sync pulses according to the PAL standard.
* FREQ: these three bits define the frequency of the master clock, from which all other clocks in the circuit are derived. Among others, the vertical refresh rate is also defined here, which can be used to improve compatibility with some VGA monitors that do not support a vertical refresh rate of 50Hz. The vertical refresh rate values are as follows:
** 000 : 50Hz for 48K and Pentagon mode.
** 001 : 50Hz for 128K mode
** 010 : 52 Hz
** 011 : 53 Hz
** 100 : 55 Hz
** 101 : 57 Hz
** 110 : 59 Hz
** 111 : 60 Hz
* ENSCAN: to 1 to enable the scanline effect in VGA mode. No effect if VGA mode is disabled.
* VGA: set to 1 to enable the scandoubler. The scandoubler output is the same as the normal RGB output, but with a doubling of the horizontal delay frequency. Set to 0 to use 15kHz RGB / composite video output.

<<<

===== `$0C` RASTERLINE

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|`11111111`|`11111111`|`11111111`
|===

Stores the least significant 8 bits of the screen line where maskable interrupt should be triggered. A value of 0 for this register (with LINE8 also equal to 0) sets the raster interrupt to be triggered, if enabled, right at the start of the right edge of the line before the first screen line where the "paper" area begins. In other words: the line count of this interrupt assumes that a screen line is composed of: right edge + horizontal blanking interval + left edge + paper zone. If this assumption is made, the interrupt would be triggered at the beginning of the selected line.
A value for RASTERLINE equal to 192 (with LINE8 equal to 0) triggers the raster interrupt at the beginning of the bottom edge. The line numbers for the end of the bottom edge and start of the top edge depend on the timings used. The highest value possible in practice for RASTERLINE corresponds to a raster interrupt triggered at the last line of the top edge (see RASTERCTRL).

===== `$0D` RASTERCTRL

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|`00000001`|`00000001`|`00000001`
|===

Raster Interrupt Status and Control Register. The following bits are defined.
|===
|INT|0|0|0|0|0|DISVINT|ENARINT|LINE8
|===
* INT: this bit is only available on read. It is set to 1 for 32 clock cycles from the time the raster interrupt is triggered. This bit is available even if the processor has interrupts disabled. It is not available if the ENARINT bit is set to 0.
* DISVINT: set to 1 to disable the vertical retrace maskable interrupts (the original ULA interrupts). After a reset, this bit is set to 0.
* ENARINT: set to 1 to enable raster line maskable interrupts. After a reset, this bit is set to 0.
* LINE8: saves bit 8 of the RASTERLINE value, so that any value between 0 and 511 can be set, although in practice, the largest value is limited by the number of lines generated by the ULA (311 in 48K mode, 310 in 128K mode, 319 in Pentagon mode). If a line number higher than the limit is set, the raster interrupt will not occur.

<<<

===== `$0E` DEVCONTROL

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|`00000000`|`00000000`
|===

Enable/disable register for different features. The following bits are defined.
|===
|DISD|ENMMU|DIROMSEL1F|DIROMSEL7F|DI1FFD|DI7FFD|DI7FFD|DITAY|DIAY
|===
* DISD: Set to 1 to disable the SPI hardware interface for SD (used in DivMMC and ZXMMC). Disabling this interface frees ports $1F on write, $3F, $E7 and $EB. After master reset, it is set to 0.
* ENMMU: set to 1 to enable the horizontal MMU used on the Timex Sinclair. Enabling this interface uses bit 7 of port $FF, port $F4 is used and a read to port $FF returns the last value written to it. After master reset, it is 0.
* DIROM1F: the value of this bit is masked with the value of bit 2 of port $1FFD according to the operation ~DIROM1F & $1FFD[2]. The net result is that if this bit is set to 1, the system will work as if the value of bit 2 of port $1FFD is always 0, regardless of the value written to it. After master reset, it is set to 0, which allows changes to bit 2 of $1FFD to be taken into account.
* DIROM7F: the value of this bit is masked with the value of bit 4 of port $7FFD according to the operation ~DIROM7F & $7FFD[4]. The net result is that if this bit is set to 1, the system will work as if the value of bit 4 of port $7FFD is always 0, regardless of the value written to it. After master reset, it is set to 0, which allows changes to bit 4 of $7FFD to be taken into account.
* DI1FFD: set to 1 to disable the +2A/+3 compatible paging system. Disabling this interface frees the $1FFD port on write. Note that the decoding of port $7FFD, if active, is different depending on whether port $1FFD is active or not.
* DI7FFD: to 1 to disable the 128K compatible paging system. Disabling this system disables the +2A/+3 paging system even if it is not explicitly disabled.
* DITAY: set to 1 to disable the second AY chip, thus disabling Turbo Sound mode.
* DIAY: set to 1 to disable the main AY chip. Disabling this chip disables the second AY chip, even if it is not explicitly disabled.

<<<

===== `$0F` DEVCTRL2

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|`00000000`|`00000000`
|===

|Enable/disable register of different features (continuation of DEVCONTROL). The following bits are defined.
|===
|Resv|Resv|SPLITTER|DIMIXER|DISPECDRUM|DIRADES|DITIMEX|DIULAPLUS
|===
* Resv: This bit is reserved. In the current implementation, a 0 must be written to it if the register value is updated.
* SPLITTER: set to 1 to enable joystick splitter.
* DIMIXER: set to 1 to disable sound output.
* DISPECDRUM: set to 1 to disable SpecDrum/Covox support.
* DIRADAS: set to 1 to disable radastanian mode. Note that if radastanian mode is not disabled, but ULAplus is disabled, when attempting to use radastanian mode, the datapath used in the ULA will not be as expected and the display behaviour in this case is not documented.
* DITIMEX: to 1 to disable Timex compatible display modes. Any writes to the $FF port are therefore ignored. If the Timex MMU is enabled, a read to port $FF will return 0.
* DIULAPLUS: set to 1 to disable the ULAplus. Any writes to the ULAplus ports are ignored. Reads to those ports return the value of the floating bus. Note however that the contention mechanism for this port still works even if it is disabled.

===== `$10` MEMREPORT

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|`00000000`|`00000000`
|===

<<<

===== `$40` RADASCTRL

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|`00000000`|`00000000`|`00000000`
|===

Register for setting the radastanian mode and  its characteristics. Writes to this register are ignored if the corresponding bit in DEVCTRL2 is set. The following bits are defined
|===
|Resv|Resv|Resv|Resv|Resv|Resv|Resv|Resv|EN1|EN0
|===
* Resv: This bit is reserved. In the current implementation, a 0 must be written to it if the register value is updated.
* EN1, EN0: Both bits must be set to 1 to enable Radastanian mode. If EN0 is enabled, but EN1 is disabled, the rest of the bits, from 2 to 7, are defined as implemented in the https://github.com/chernandezba/zesarux[ZEsarUX emulator] (see César Hernández's documentation on this).

===== `$41` RADASOFFSET

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|`00000000`|`00000000`|`00000000`
|===

Contains the number of bytes to be added to the base address of the screen (4000h, 6000h, C000h or E000h depending on the configuration) to obtain the address where the first two pixels are located in Radastanian mode. It is a 14-bit register. To write a value, the 8 least significant bits are written first, followed immediately by the 8 most significant bits (the 2 most significant bits of this value are ignored).
If the offset value is such that scanning the screen memory to create the image reaches the end of a 16KB page, scanning will continue at the beginning of that same page.

===== `$42` RADASPADDING

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|`00000000`|`00000000`|`00000000`
|===

Contains the number of bytes - 64 that a scanline occupies in Radastanian mode. That is, if this register is 0, the length in bytes of a scanline is 64 bytes (128 pixels). If this register is 4, the length of a scanline is 68 bytes (136 pixels). If it is 255, the length of a scanline is 64+255=319 bytes, or 638 pixels.
If the offset value is such that scanning the screen memory to create the image reaches the end of a 16KB page, scanning will continue at the beginning of that same page.

<<<

===== `$43` RADASPALBANK

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|`00000000`|`00000000`|`00000000`
|===

Register used to set which section of the ULAplus palette will define the colours in Radastanian mode, and how the border will behave.
|===
|Resv|Resv|Resv|Resv|Resv|Resv|BOR3 |RADPALQUARTER
|===
* Resv: This bit is reserved. In the current implementation, a 0 must be written to it if the register value is updated.
* BOR3: Within the currently selected palette, indicates whether the border colour will be taken from entries 0 to 7 (0) or from entries 8 to 15 (1). It can be considered as bit 3 of the border colour in Radastanian mode.
* RADPALQUARTER: two bits indicating which section of the ULAplus palette is to be used for the Radastanian mode. 00 for using the section of inputs 0 to 15. 01 for inputs 16 to 31, 10 for inputs 32 to 47 and 11 for using inputs 48 to 63.

===== `$80` HOFFS48K

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|Does not change|`$38`
|===

Horizontal screen centering adjustment value for 48K ULA.

===== `$81` VOFFS48K

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|Does not change|`$01`
|===

Vertical screen centering adjustment value for 48K ULA.

===== `$82` HOFFS128K

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|Does not change|`$3A`
|===

Horizontal screen centering adjustment value for 128K ULA.

===== `$83` VOFFS128K

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|Does not change|`$01`
|===

Vertical screen centering adjustment value for 128K ULA.

===== `$84`

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|`HOFFSPEN`
|Read/Write|Does not change|Does not change|`$37`
|===

Horizontal screen centering adjustment value for Pentagon ULA.

===== `$85` VOFFSPEN

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|Does not change|`$00`
|===

Vertical screen centering adjustment value for Pentagon ULA.

===== `$A0` DMACTRL

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|`00000000`|`00000000`
|===

===== `$A1` DMASRC

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|`00000000`|`00000000`
|===

===== `$A2` DMADST

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|`00000000`|`00000000`
|===

<<<

===== `$A3` DMAPRE

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|`00000000`|`00000000`
|===

===== `$A4` DMALEN

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|`00000000`|`00000000`
|===

===== `$A5` DMAPROB

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|`00000000`|`00000000`
|===

===== `$A6` DMASTAT

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|`00000000`|`00000000`
|===

===== `$C6` UARTDATA

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|`00000000`|`00000000`
|===

===== `$C7` UARTSTAT

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|`00000000`|`00000000`
|===

===== `$C8` - `$DF` RESERVED

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Definido por el usuario|Definido por el usuario|Definido por el usuario
|===

ZXUNO registers reserved for experiments or private use.

===== `$F0` SRAMADDR

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|`00000000`|`00000000`
|===

===== `$F1` MADDRINC

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|`00000000`|`00000000`

===== `$F2` SRAMDATA

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Lectura/Escritura|Does not change|`00000000`|`00000000`

===== `$F3` VDECKCTRL

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|`00000000`|`00000000`
|===

===== `$F7` AUDIOMIX

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|Does not change|`10011111`
|===

Control of the left/right channel mix from the 4 channels of the AY-8912. The following groups of 2 bits each are defined:
|===
|=== |CHANNELA|CHANNELB|CHANNELC|BEEPDRUM
|===
* BEEPDRUM : Channel for Beeper and Specdrum.
* The meaning of each group of 2 bits is: 00 = Mute, 01 = Right channel, 10 = Left channel, 11 = Both.

<<<

===== `$FB` AD724

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|Does not change|`00000000`
|===

Control of the operating mode of the AD724 encoder chip. The following bits are defined:
|==
|Resv|Resv|Resv|Resv|Resv|Resv|Resv|Resv|Resv|MODE
|==
* Resv : the meaning of these bits is reserved and must not be altered.
* MODE : operating mode of the AD724. 0 = encodes PAL standard. 1 = encodes NTSC standard.

===== `$FC` COREADDR

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|Does not change|`$058000`
|===
Stores the address, within SPI memory, of the start of the core to be booted. To store a different address, three writes must be made to this register, containing the three bytes of the address, in order from most significant to least significant. On read, each access to this register returns a part of the last stored address, from the most significant part to the least significant part.

===== `$FD` COREBOOT

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read|Does not change|Does not change|Does not change
|===

Boot control register. Writing a 1 to bit 0 of this register (all other bits are reserved and must remain at 0) triggers the FPGA's internal mechanism to start another core. The start address of this second core will be the last one written using the COREADDR register.

===== `$FE` SCRATCH

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read/Write|Does not change|`00000000`|`00000000`
|===

<<<

====== `$FF` COREID

[align="center",options="header"]
|===
|Direction|Value after user reset|Value after master reset|Value after poweron
|Read|Read later|Read later|Read later
|===

Each read operation provides the next ASCII character of the string containing the current revision of the ZX-Uno core. When the string ends, subsequent reads output bytes with the value 0 (at least on) until the string starts again. This pointer returns to 0 automatically after a reset or a write to the `$FC3B` register. The delivered characters that are part of the string are standard printable ASCII (codes `32`-`127`). Any other value indicates that this register is not operational.

<<<

=== Links

https://zxuno.speccy.org/index.shtml[ZX-Uno]

http://desubikado.sytes.net/zx-uno-faq-version-desubikado/[ZX-Uno FAQ]

https://docs.google.com/document/d/1NI0zgCDRk7c-5CVi-lfZEK6q8Lnpnco7PhpsEEdxD60/edit[ZX-Uno Quick Guide]

https://www.zxuno.com/wiki/index.php/ZX_Spectrum[ZX Spectrum core]

https://worldofspectrum.org/zxplus3e/index.html[The ZX Spectrum +3e Homepage]

https://worldofspectrum.org/zxplus3e/sharingdisks.html[Sharing a +3e disk with PC (FAT) partitions]

https://www.zxuno.com/wiki/index.php?title=Boot_Firmware[ZX-Uno Wiki]

https://www.zxuno.com/forum/viewtopic.php?f=37&t=208[Keyboard Layouts]

https://github.com/spark2k06/zxunops2/blob/master/Alternative/Nuevo%20firmware%20de%20teclado%20ZX-GO%2B.pdf[Keyboard firmware for ZX Go+]

https://github.com/zxdos/zxdos-plus/tree/master/zxunops2[zxunops2]

https://docs.google.com/spreadsheets/d/17-ifpHcy932_AP7SAv9uBLxg-2ZptcdgTvQ8ILXQLM4/htmlview[Almost (In-) Complete List of esxDOS DOT-Commands]

https://www.va-de-retro.com/foros/viewtopic.php?t=1718&start=10%23p25076[Cargando Leches 2.0]

http://retrowiki.es/viewtopic.php?f=83&t=200032578&p=200075671%23p200075671[WiFi (RetroWiki)]

https://www.zxuno.com/forum/viewtopic.php?f=35&t=44[WiFi on ZX-Uno]

https://svn.zxuno.com/svn/zxuno/cores/spectrum_v2_spartan6/test19_multi_uart/[ZX-Uno Core Test UART (WiFi)]

https://www.retrowiki.es/viewtopic.php?f=110&t=200039549[Distribución para ZX-Uno (ver. 30.06.2023) Summer of '23 Edition]

https://nihirash.net/projects/[Nihirash Projects]

https://www.zxuno.com/forum/viewtopic.php?f=25&t=4079[Wi-Fi addon at the ZX-Uno forum]

https://zxuno.com/forum/viewtopic.php?t=4108[PLATO client at the ZX-Uno forum] 

https://zxuno.com/forum/viewtopic.php?t=3963[MIDI addon at the ZX-Uno forum]

https://www.espressif.com/sites/default/files/documentation/4a-esp8266_at_instruction_set_en.pdf[ESP8266 AT Instruction Set]

https://www.zonadepruebas.com/viewtopic.php?t=4796&start=110[Radastanian Vídeos]

https://www.zxuno.com/forum/viewtopic.php?f=52&t=4074&p=28234%23p28234[New core zx48]

https://github.com/rcmolina/MaxDuino_BETA/blob/master/MANUAL%20por%20desUBIKado/MAXDUINO%20Gu%C3%ADa%20de%20uso.pdf[Maxduino - User's Guide]

https://retroramblings.net/?page_id=1422[Minimig AGA for Turbo Chameleon 64]

https://www.forofpga.es/viewtopic.php?t=349[Core ZXNEXT en ZXDOS]

https://gitlab.com/thesmog358/tbblue/-/blob/master/docs/zxdos/zxdoscoreinstall.txt[ZX Spectrum Next with ZXDOS]

https://www.zxuno.com/wiki/index.php?title=ZX_Spectrum[About Spectrum at ZX-Uno Wiki]
